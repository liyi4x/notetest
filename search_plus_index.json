{"./":{"url":"./","title":"Introduction","keywords":"","body":"Notes github pages gitbook pages 123 "},"ROS/":{"url":"ROS/","title":"ROS","keywords":"","body":"ROS机器人操作系统 "},"ROS/ROS开发环境.html":{"url":"ROS/ROS开发环境.html","title":"ROS开发环境","keywords":"","body":"ROS开发环境 1. 版本选择 ROS版本 Ubuntu 版本 ROS Kinetic Kame Ubuntu 16.04 ROS Melodic Morenia Ubuntu 18.04 ROS Noetic Ninjemys Ubuntu 20.04 ros的各个版本之间不相互兼容，安装前需要注意版本对应 2. 添加软件源 使用中科大的镜像源安装ROS sudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main\" > /etc/apt/sources.list.d/ros-latest.list' 3. 添加keys sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 apt-key用于管理Debian Linux系统中的软件包密钥。每个发布的deb包，都是通过密钥认证的，apt-key用来管理密钥。 4. 更新软件源 sudo apt-get update sudo apt-get upgrade update是更新软件列表，upgrade是更新已安装的软件 参考apt-get update与upgrade的区别 5. 安装ROS ros官方提供四种安装方式，Ubuntu16.04安装Kinetic版本 桌面完整版安装 包括ROS、rqt、rviz、通用机器人函数库、2D/3D仿真器、导航以及2D/3D感知功能 sudo apt-get install ros-kinetic-desktop-full 桌面版安装 包含ROS、rqt、rviz以及通用机器人函数库 sudo apt-get install ros-kinetic-desktop 基础版安装 包含ROS核心软件包、构建工具以及通信相关的程序库，无GUI工具 sudo apt-get install ros-kinetic-ros-base 单独软件包安装 可以用来安装指定软件包，这种安装方式在运行ROS缺少某些package依赖时会经常用到。 sudo apt-get install ros-kinetic-PACKAGE 用包名替代上述命令中的PACKAGE可安装相应的功能包 6. 配置ROS 6.1. 初始化rosdep sudo rosdep init sudo rosdep update 这里可能会因为github站点网络链接问题而报错，使用代理即可解决 6.2. ROS环境变量设置 echo \"source /opt/ros/kinetic/setup.bash\" >> ~/.bashrc 相当于每次打开终端都执行遍source命令 6.3. 安装rosinstall sudo apt-get install python-rosinstall 7. 测试ROS环境 7.1. 启动roscore roscore 成功启动后如下图所示 7.2. 启动海龟测试节点 rosrun turtlesim turtlesim_node turtlesim_node节点是模拟海龟运动的节点 7.3. 启动控制节点 rosrun turtlesim turtle_teleop_key turtle_teleop_key节点是键盘控制节点 "},"ROS/二进制包和源码包.html":{"url":"ROS/二进制包和源码包.html","title":"二进制包和源码包","keywords":"","body":"二进制包和源码包 1. 区别 二进制包是可以直接通过使用sudo apt-get install命令进行安装的，能够直接使用而无需重新编译。 源代码包是程序的源代码，能够根据具体情况进行修改，再经过计算机编译，生成二进制可执行文件才能运行。 区别 二进制包 源代码包 下载方式 sudo apt-get install git clone ROS包存放位置 /opt/ros/kinetic/ 随意存放，一般为工作目录 应用场景 基础软件 第三方程序，需要修改的源码 2. ROS二进制包的安装 例如安装GMapping包 sudo apt-get install ros-kinetic-slam-gmapping 所有apt官方的ROS功能包命名均为ros-版本代号-功能包名, kinect为Ubuntu16.04下的ROS的名称 3. 源码安装 以ROS-Academy-for-Beginners为例进行安装 3.1. 创建工作空间 mkdir -p ~/tutorial_ws/src cd tutorial_ws/src 3.2. 下载源码 git clone https://github.com/DroidAITech/ROS-Academy-for-Beginners.git 3.3. 安装依赖 在ros工作空间内安装全部包的依赖 cd ~/tutorial_ws rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 另外需要Gazebo的版本高于 7.0，可通过gazebo -v查看当前版本，升级步骤如下 sudo sh -c 'echo \"deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\" > /etc/apt/sources.list.d/gazebo-stable.list' wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt-get update sudo apt-get install gazebo7 3.4. 编译 cd ~/tutorial_ws catkin_make source ~/tutorial_ws/devel/setup.bash source命令在每一次打开新终端的时候都要执行一次，故可以写入~/.bashrc catkin_make是一个编译构建系统 3.5. 运行仿真程序 roslaunch robot_sim_demo robot_spawn.launch "},"ROS/ROS工作空间.html":{"url":"ROS/ROS工作空间.html","title":"ROS工作空间","keywords":"","body":"ROS工作空间 1. Catkin编译系统 源码需要编译、链接等步骤才能生成二进制可执行文件，对于 ROS 等大型项目而言，需要管理项目结构，进行自动化编译等。 Catkin 是 ROS 对 CMake 进行拓展之后的，CMake 能够生成makefile文件，进而能够控制编译的过程 Catkin 编译系统的层级结构如图 1.1. Catkin编译流程 在工作空间catkinws/src/下进行递归查询每一个ROS包 ROS包中有package.xml和CMakeLists.txt文件，则根据CMakeLists.txt生成相应的makefile文件 再 make 进行编译 相当于catkin_make是将cmake与make进行了合并操作，同时提高了跨项目依赖性 1.2. 使用catkin_make进行编译 必须要在工作空间的目录下执行catkin_make，之后需要source命令更新环境变量，否则rosrun无法执行ros包 cd ~/catkinws catkin_make source ./devel/setup.bash 2. ROS工作空间结构 ─ build │ ├── catkin │ │ └── catkin_generated │ │ └── version │ │ └── package.cmake │ ├── ...... │ ├── catkin_make.cache │ ├── CMakeCache.txt │ ├── CMakeFiles │ │ ├── ...... ├── devel │ ├── env.sh │ ├── lib │ ├── setup.bash │ ├── setup.sh │ ├── _setup_util.py │ └── setup.zsh └── src └── CMakeLists.txt -> /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake src/用于存放各种package，其中同一类多个功能包可以存放在一个子目录下 build/用于存放编译过程中的中间文件，缓存信息等 devel/用于存放生成的目标文件，包括可执行文件，静态链接库，动态链接库等 src/下的源代码，经过编译生成中间文件，存在build/下，build/下的文件再经过链接等处理，最后生成可执行文件，库文件等，存放在devel/ src/下允许存在多个package，在ROS工作空间下的各个package可以在子目录下 "},"ROS/packages.html":{"url":"ROS/packages.html","title":"packages","keywords":"","body":"packages 1. package结构 package是catkin编译的基本单元，一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等） ├── CMakeLists.txt #package的编译规则(必须) ├── package.xml #package的描述信息(必须) ├── src/ #源代码文件 ├── include/ #C++头文件 ├── scripts/ #可执行脚本 ├── msg/ #自定义消息 ├── srv/ #自定义服务 ├── action/ #自定义服务 ├── models/ #3D模型文件 ├── urdf/ #urdf文件 ├── launch/ #launch文件 ├── config/ #参数配置文件 CMakeLists.txt文件和package.xml文件，这两个文件定义了package CMakeLists.txt定义的是package的编译规则，用到的依赖关系等 package.xml定义的是功能包相关的信息，描述package的包名、版本号、作者、依赖等信息 src/存放的是源代码文件，主要是cpp源码以及python的module文件 include/存放的是hpp头文件 scripts/存放的是脚本文件，shell脚本、python脚本等 msg/存放的是自定义格式的消息文件（*.msg） srv/存放的是自定义格式的服务文件（*.srv） action/存放的是自定义格式的动作文件（*.action） models/存放机器人或仿真场景的3D模型（.sda, .stl, .dae等） urdf/存放机器人的模型描述（.urdf, .xacro） launch/存放的是启动文件（*.launch） config/存放的是全局配置文件（*.yaml） 2. 创建package 创建一个package需要在catkin_ws/src/下，用到catkin_create_pkg命令，相当于脚手架，搭建package框架结构 catkin_create_pkg package depends 其中package是包名，depends是依赖的包名，可以依赖多个软件包。 例如，新建一个package叫做test_pkg，依赖roscpp、rospy、std_msgs(常用依赖)。 catkin_create_pkg test_pkg roscpp rospy std_msgs 此时目录结构为 ├── CMakeLists.txt ├── include │ └── test_pkg ├── package.xml └── src catkin_create_pkg默认创建好了CMakeLists.txt和package.xml，并将项目依赖项添加到了package.xml 3. package相关的命令 3.1. rospack rospack是ros的package管理工具 rostopic命令 作用 rospack help 显示rospack的用法 rospack list 列出本机所有package rospack depends [package] 显示package的依赖包 rospack find [package] 定位某个package rospack profile 刷新所有package的位置记录 package缺省则默认为当前目录下的package 3.2. roscd roscd命令类似与Linux系统的cd，改进之处在于roscd可以直接改变目录到ROS的软件包目录下 3.3. rosls rosls也可以视为Linux指令ls的改进版，可以直接在任意目录下列出相应ROS软件包的内容 rosls [pacakge]列出pacakge下的文件 3.4. rosdep rosdep是用于管理ROS package依赖项的命令行工具 rosdep命令 作用 rosdep check [pacakge] 检查package的依赖是否满足 rosdep install [pacakge] 安装pacakge的依赖 rosdep db 生成和显示依赖数据库 rosdep init 初始化/etc/ros/rosdep中的源 rosdep keys 检查package的依赖是否满足 rosdep update 更新本地的rosdep数据库 一个较常使用的命令是rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y，用于安装工作空间中src路径下所有package的依赖项（由pacakge.xml文件指定） 4. Metapackage元功能包 4.1. Metapackage介绍 Metapackage是一个功能包集合，把几个相近的功能模块、软件包放到一起，之前叫Stack。元功能包本身没有实质性的功能，但是依赖于多个软件包，相当于一个集合 ROS里常见的Metapacakge有： Metapacakge名称 描述 链接 navigation 导航相关的功能包集 https://github.com/ros-planning/navigation moveit 运动规划相关的（主要是机械臂）功能包集 https://github.com/ros-planning/moveit image_pipeline 图像获取、处理相关的功能包集 https://github.com/ros-perception/image_common vision_opencv ROS与OpenCV交互的功能包集 https://github.com/ros-perception/vision_opencv turtlebot Turtlebot机器人相关的功能包集 https://github.com/turtlebot/turtlebot pr2_robot pr2机器人驱动功能包集 https://github.com/PR2/pr2_robot ... ... ... 以上列举了一些常见的功能包集，例如navigation、turtlebot，他们都是用于某一方面的功能，以navigation metapackage（官方介绍里仍然沿用stack的叫法）为例，它包括了以下软件包： 包名 功能 navigation Metapacakge，依赖以下所有pacakge amcl 定位 fake_localization 定位 map_server 提供地图 move_base 路径规划节点 nav_core 路径规划的接口类 base_local_planner 局部规划 dwa_local_planner 局部规划 ... ... 4.2. Metapackage结构 我们以ROS-Academy-for-beginners为例介绍meteapckage的写法，在教学包内，有一个ros-academy-for-beginners软件包，该包即为一个metapacakge，其中有且仅有两个文件：CMakeLists.txt和pacakge.xml。 CMakeLists.txt写法如下： cmake_minimum_required(VERSION 2.8.3) project(ros_academy_for_beginners) find_package(catkin REQUIRED) catkin_metapackage() #声明本软件包是一个metapacakge pacakge.xml写法如下： ros_academy_for_beginners 17.12.4 -------------------------------------------------------------------------- A ROS tutorial for beginner level learners. This metapacakge includes some demos of topic, service, parameter server, tf, urdf, navigation, SLAM... It tries to explain the basic concepts and usages of ROS. -------------------------------------------------------------------------- Chai Changkun Chai Changkun BSD http://http://www.droid.ac.cn catkin navigation_sim_demo param_demo robot_sim_demo service_demo slam_sim_demo tf_demo topic_demo metapacakge中的以上两个文件和普通pacakge不同点是： CMakeLists.txt:加入了catkin_metapackage()宏，指定本软件包为一个metapacakge。 package.xml:标签将所有软件包列为依赖项，标签中添加标签声明。 metapacakge在我们实际开发一个大工程时可能有用 "},"ROS/package.xml.html":{"url":"ROS/package.xml.html","title":"package.xml","keywords":"","body":"package.xml 1. package.xml作用 package.xml也是一个catkin的package必备文件，它是这个软件包的描述文件，用于描述pacakge的基本信息。pacakge.xml包含了package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。 实际上rospack find、rosdep等命令之所以能快速定位和分析出package的依赖项信息，就是直接读取了每一个pacakge中的package.xml文件。它为用户提供了快速了解一个pacakge的渠道。 2. package.xml写法 目前Indigo、Kinetic、Lunar等版本的ROS都同时支持两种版本的package.xml，所以无论选format1还是format2都可以。 参考解析 package.xml 文件 2.1. format2 在新版本（format2）中，包含的标签为： 标签名 作用 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 指定依赖项为编译、导出、运行需要的依赖，最常用 编译依赖项 导出依赖项 运行依赖项 测试用例依赖项 文档依赖项 相当于、、 ,相当于将之前的build和run依赖项描述进行了细分。 每个ROS功能包都至少有一个依赖项，一个指定了构建、执行、测试、文档依赖项的 xml 文件如下： sensor_funsion 1.2.3 This package fusion point cloud and image. www.xxx.com DLonng xxx BSD catkin roscpp std_msgs message_generation message_runtime rospy python-mock doxygen 2.2. format1 pacakge.xml遵循xml标签文本的写法，由于版本更迭原因，现在有两种格式并存（format1与format2），不过区别不大。老版本（format1）的pacakge.xml通常包含以下标签: 标签名 作用 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 编译依赖项 运行依赖项 测试用例依赖项 sensor_funsion 1.2.3 This package fusion point cloud and image. www.xxx.com DLonng xxx BSD 3. pacakge.xml例子 为了说明pacakge.xml写法，还是以turtlesim软件包为例，其pacakge.xml文件内容如下，我们添加了相关的注释： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs qtbase5-dev message_generation qt5-qmake rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs geometry_msgs libqt5-core libqt5-gui message_runtime rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs 以上内容是老版本（format1）的写法，如果要写成新版本（format2）则可以改为： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs qtbase5-dev message_generation qt5-qmake libqt5-core libqt5-gui message_runtime "},"ROS/CMakeLists.txt.html":{"url":"ROS/CMakeLists.txt.html","title":"CMakeLists.txt","keywords":"","body":"CMakeLists.txt CMakeLists.txt原本是Cmake编译系统的规则文件，而Catkin编译系统基本沿用了CMake的编译风格，只是针对ROS工程添加了一些宏定义。所以在写法上，catkin的CMakeLists.txt与CMake的基本一致。 CMake参考资料 cmake-practice.pdf 解析CMakeList.txt文件 这个文件直接规定了这个package要依赖哪些package，要编译生成哪些目标，如何编译等等流程。所以CMakeLists.txt非常重要，它指定了由源码到目标文件的规则，catkin编译系统在工作时首先会找到每个package下的CMakeLists.txt，然后按照规则来编译构建。 turtlesim的CMakeLists 以turtlesim小海龟这个pacakge为例，roscd tuetlesim查看，在turtlesim/CMakeLists.txt的写法如下: cmake_minimum_required(VERSION 2.8.3) #CMake至少为2.8.3版 project(turtlesim) #项目(package)名称为turtlesim，在后续文件中可使用变量${PROJECT_NAME}来引用项目名称turltesim find_package(catkin REQUIRED COMPONENTS geometry_msgs message_generation rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs ) #cmake宏，指定依赖的其他pacakge，实际是生成了一些环境变量，如_FOUND, _INCLUDE_DIRS, _LIBRARYIS #此处catkin是必备依赖 其余的geometry_msgs...为组件 find_package(Qt5Widgets REQUIRED) find_package(Boost REQUIRED COMPONENTS thread ) include_directories(include ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS}) #指定C++的头文件路径 link_directories(${catkin_LIBRARY_DIRS}) #指定链接库的路径 add_message_files(DIRECTORY msg FILES Color.msg Pose.msg ) #自定义msg文件 add_service_files(DIRECTORY srv FILES Kill.srv SetPen.srv Spawn.srv TeleportAbsolute.srv TeleportRelative.srv ) #自定义srv文件 generate_messages(DEPENDENCIES geometry_msgs std_msgs std_srvs) #在add_message_files、add_service_files宏之后必须加上这句话，用于生成srv msg头文件/module，生成的文件位于devel/include中 catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs ) # catkin宏命令，用于配置ROS的package配置文件和CMake文件 # 这个命令必须在add_library()或者add_executable()之前调用，该函数有5个可选参数： # (1) INCLUDE_DIRS - 导出包的include路径 # (2) LIBRARIES - 导出项目中的库 # (3) CATKIN_DEPENDS - 该项目依赖的其他catkin项目 # (4) DEPENDS - 该项目所依赖的非catkin CMake项目。 # (5) CFG_EXTRAS - 其他配置选项 set(turtlesim_node_SRCS src/turtlesim.cpp src/turtle.cpp src/turtle_frame.cpp ) set(turtlesim_node_HDRS include/turtlesim/turtle_frame.h ) #指定turtlesim_node_SRCS、turtlesim_node_HDRS变量 qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS}) add_executable(turtlesim_node ${turtlesim_node_SRCS} ${turtlesim_node_MOCS}) # 指定可执行文件目标turtlesim_node target_link_libraries(turtlesim_node Qt5::Widgets ${catkin_LIBRARIES} ${Boost_LIBRARIES}) # 指定链接可执行文件 add_dependencies(turtlesim_node turtlesim_gencpp) add_executable(turtle_teleop_key tutorials/teleop_turtle_key.cpp) target_link_libraries(turtle_teleop_key ${catkin_LIBRARIES}) add_dependencies(turtle_teleop_key turtlesim_gencpp) add_executable(draw_square tutorials/draw_square.cpp) target_link_libraries(draw_square ${catkin_LIBRARIES} ${Boost_LIBRARIES}) add_dependencies(draw_square turtlesim_gencpp) add_executable(mimic tutorials/mimic.cpp) target_link_libraries(mimic ${catkin_LIBRARIES}) add_dependencies(mimic turtlesim_gencpp) # 同样指定可执行目标、链接、依赖 install(TARGETS turtlesim_node turtle_teleop_key draw_square mimic RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}) # 安装目标文件到本地系统 install(DIRECTORY images DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION} FILES_MATCHING PATTERN \"*.png\" PATTERN \"*.svg\") "},"ROS/ROS通信架构.html":{"url":"ROS/ROS通信架构.html","title":"ROS通信架构","keywords":"","body":"ROS通信架构 1. Node & Master ROS通信系统是一个由ROS进程组成的点对点网络，如图所示ROS系统分为一个Master和多个Node节点，Node向Master注册，Node之间的通信则不需要通过Master，可以直接进行点对点的通信。ROS的通信方式主要有： topic话题 service服务 action动作 Parameter Service参数服务器 1.1. Node Node是ROS的最小运行单元，在ROS里每个进程都是一个Node，每个package的可执行文件都是一个Node，代表的是一种功能。对于机器人编程而言，需要对机器人各个功能进行分离，因此最终一个机器人系统会由多个Node组成 机器人多个Node组成的优点 提高系统的鲁棒性，能在某些节点出问题的情况下不影响其他节点 降低系统的耦合程度，提高系统的可移植性和可调试性 1.2. Master Master是ROS的节点管理器，用于管理ROS中的所有Node，Node在启动之后的第一件事就是需要向Master注册，以便能够完成各个节点之间的通信等操作。所以在启动Node之前需要保证Master的工作正常 当一个节点开始发布一个topic，节点将会将topic的名字和数据类型信息传递给Master，Master将会检查是否有其他的节点订阅了这个topic，如果有任何的节点订阅了这个topic，Master将会共享发布者的消息给订阅者节点。 1.3. 分布式ROS 对于单机ROS系统而言，ROS的各个Node和Master可以不用考虑URI问题。但是对于分布式系统而言，ROS系统需要知道每个分布式主机对应的Node的地址（IP和端口）。分布式ROS系统中的Master同样只能有一个，且需要在Node之前启动。 通过设置ROS_MASTER_URI环境变量来完成局域网内主机对Master的定位，进而进行接下来的Node启动等工作 ROS的各个主机之间的通信是通过{主机名}:{端口号}的形式进行通信的，因此需要修改局域网内的ROS主机的host文件来定位 参考文件 ros分布式多机通信 - CSDN ROS分布式多机通信 - 知乎 2. ROS启动流程 2.1. 启动roscore roscore 与此同时启动的还有 rosout rosout是一个节点，主要作用就是日志输出，告之用户当前系统的运行状态，系统运行过程中的error和warning，并将log记录在文件中方便后期复盘 parameter server parameter server是参数服务器，主要作用是维护系统运行中的全局参数，各个节点都可以读取参数服务器中的数据 2.2. 启动Node rosrun启动一个节点 rosrun pkg_name node_name pkg_namepackage名字 node_namepackage下的node名 Node管理相关的命令rosnode rosnode命令 作用 rosnode list 列出当前运行的node信息 rosnode info node_name 显示出node的详细信息 rosnode kill node_name 结束某个node rosnode ping 测试连接节点 rosnode machine 列出在特定机器或列表机器上运行的节点 rosnode cleanup 清除不可到达节点的注册信息 "},"ROS/Launch文件.html":{"url":"ROS/Launch文件.html","title":"Launch文件","keywords":"","body":"Launch 1. 通过Launch文件启动ROS 当一个机器人系统拥有多个Node时，可以使用launch文件来组织这些节点。通过对launch文件的配置，可以达到“一键启动的效果”roslaunch就是一个启动管理器。一般情况下整个系统的启动文件是在{name}_bringup包下的{name}.launch roslaunch pkg_name file_name.launch roslaunch命令会首先检查roscore是否成功启动，即判断节点管理器master是否正常运行如若没有启动会在启动节点之前先启动roscere 2. launch文件语法格式 launch文件本质也是xml文件，因此语法格式满足xml文件的标准，它包括的标签 标签 作用 根标签 需要启动的node及其参数 包含其他launch 指定运行的机器 设置环境变量 定义参数到参数服务器 启动yaml文件参数到参数服务器 定义变量 设定参数映射 设定命名空间 每个标签有多个属性，具体含义参考wiki name 节点重命名，相当于节点的第二个名字，这个可以重复 pkg 节点所在的package名 type 在package里的节点名，使用rosrun命令是的node名 name 变量名 default 默认值（可选） value 变量值（可选） file 格式为$(find pkg_name)/path/filename.xml 3. 示例文件 最简单的launch文件只需要有node即可，比如启动rospy_tutorials包下的talker节点 而在实际应用时的launch文件就复杂一些，robot_sim_demo下的robot_spawn.launch文件如下 robot_spawn.launch中引用的xbot-u.launch.xml文件的内容如下 --> --> "},"ROS/Topic和msg.html":{"url":"ROS/Topic和msg.html","title":"Topic和msg","keywords":"","body":"Topic和msg 1. Topic ROS的Topic通信通常用于实时性、周期性的消息通信，Topic是一个点对点的通信模型，这里的点指的是节点（Node），通信模型是 发布-订阅 模型，要建立通信需要经过几个步骤 发布者（Publisher）和订阅者（Subscriber）节点向Master注册 发布者发布一个话题 Master指挥订阅者进行订阅相应的话题 建立起发布者到订阅者的单向点对点通信 一个Topic可以被多个订阅者订阅，多个发布者也可以向同一个Topic发布消息，订阅者和发布者之间的通信是直接进行的，不经过Master转发，只是订阅者从Master处获取订阅的话题信息，建立通信 Topic通信是异步通信，发布者发布消息之后继续执行相应的工作，不等待任何人反馈，订阅者在收到发布者发布的消息之后，调用回调函数进行消息处理。 参考ROS多个传感器publish同一个Topic 1.1. rostopic命令 命令 作用 rostopic help 帮助，查询相关命令具体用法 rostopic list 列出当前所有的topic rostopic info topic_name 显示某个topic的属性信息 rostopic echo topic_name 显示某个topic的内容 rostopic pub topic_name ... 向某个topic发布内容 rostopic bw topic_name 查看某个topic的带宽 rostopic hz topic_name 查看某个topic的频率 rostopic find topic_type 查找某个类型的topic rostopic type topic_name 查看某个topic的类型(msg) 1.2. 通信示例 机载平台采集并处理摄像头信息，笔记本电脑上对摄像头的数据进行显示，这里有三个节点 Node1摄像头节点 控制摄像头采集数据，运行在机载平台 Node2图像处理节点 对摄像头采集的数据进行处理，保障机器人的后续功能，运行在机载平台 Node3图像显示节点 对摄像头采集的数据在笔记本电脑上进行显示，运行在远程笔记本平台上 三个节点加入ROS通信网络，向Master节点进行注册，Node1摄像头节点启动之后作为发布者开始向/camera_rgb话题发布数据，Node2图像处理节点和Node3图像显示节点启动后作为订阅者，经过Master节点管理器的控制，分别和Node1摄像头节点建立通信 Node1摄像头节点只管发布数据，不关心Node2图像处理节点和Node3图像显示节点是否收到消息、是否处理完消息，同样Node2图像处理节点和Node3图像显示节点只在接收到Node1摄像头节点发布的消息之后对消息进行相应的处理，不关心Node1摄像头节点在什么时候发布消息，处理完消息之后不需要向Node1摄像头节点发送任何反馈，这体现了Topic通信的异步性质 2. Message Topic通信过程中的数据发布与订阅处理等有严格的格式要求，需要预先约定消息的格式，通过Message来确定数据格式，例如上述示例中的/camera_rgb话题，这个话题的消息格式只能是ROS中定义好的RGB图像格式，这种数据格式就是Message。Message定义在msg/下的*.msg文件中 2.1. rosmsg命令 rosmsg命令 作用 rosmsg list 列出系统上所有的msg rosmsg show msg_name 显示某个msg的内容 2.2. 结构与类型 Message有几种基本的数据类型 bool int8 int16 int32 int64 uint float float64 string time duration header array[] 可变长数组 array[C] 固定长度数组 每个*.msg文件的文件名又形成了一个新的数据结构，可以在其他的*.msg文件中直接使用，类似与C语言中的struct结构体 2.3. msg文件示例 ROS定义的Header.msg # 定义数据的参考时间和参考坐标 # 文件位置:std_msgs/Header.msg uint32 seq #数据ID time stamp #数据时间戳 string frame_id #数据的参考坐标系 用户自定义的Vector3.msg # 三维度向量 # 位置:geometry_msgs/Vector3.msg float64 x float64 y float64 z 用户自定义的Quaternion.msg # 消息代表空间中旋转的四元数 # 位置:geometry_msgs/Quaternion.msg float64 x float64 y float64 z float64 w 用户自定义的Imu.msg # 消息包含了从惯性原件中得到的数据，加速度为m/^2，角速度为rad/s # 如果所有的测量协方差已知，则需要全部填充进来 # 如果只知道方差，则只填充协方差矩阵的对角数据即可 # 位置：sensor_msgs/Imu.msg Header header Quaternion orientation float64[9] orientation_covariance Vector3 angular_velocity float64[9] angular_velocity_covariance Vector3 linear_acceleration float64[] linear_acceleration_covariance "},"ROS/Service和srv.html":{"url":"ROS/Service和srv.html","title":"Service和srv","keywords":"","body":"Service和srv 1. Service servivce是一种 请求-查询 的通信模型，适用于那些临时、非周期性的数据需求的节点使用。双向通信，不仅可以发送消息，而且还可以接受反馈。使用service通信，消息的提供者不需要一直向外发送数据，仅在请求方有消息请求的时候才发送数据。 service的通信包括两部分 请求方（Client） 服务提供方（Server） service通信是一种同步通信，请求方向服务方发送一个request，请求方会等待服务方的reply，收到reply之后再进行接下来的工作；服务方在接收到request之后，进行相应的消息处理，并返回一个reply 1.1. 和topic通信方式对比 topic service 通信方式 异步通信 同步通信 通信方向 单向通信 双向通信 实现原理 TCP/IP TCP/IP 通信模型 Publish-Subscribe Request-Reply 映射关系 Publish-Subscribe（多对多） Request-Reply（多对一） 特点 接受者收到数据会回调（Callback） 远程过程调用（RPC）服务器端的服务 应用场景 连续、高频的数据发布 偶尔使用的功能/具体的任务 举例 激光雷达、里程计发布数据 开关传感器、拍照、逆解计算 远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。 1.2. rosservice命令 rosservice 命令 作用 rosservice list 显示服务列表 rosservice info 打印服务信息 rosservice call 使用所提供的args调用服务 rosservice type 打印服务类型 rosservice uri 打印服务ROSRPC uri rosservice find 按服务类型查找服务 rosservice args 打印服务参数 1.3. 通信示例 打开模拟场景roslaunch robot_sim_demo robot_spawn.launch。 输入rosservice list，可以查看当前运行的服务。 例如/gazebo/delete_light服务，是删除光源的操作。 输入rosservice info /gazebo/delete_light查看属性信息。可以看到信息，Node：/gazebo，Type：gazebo_msgs/DeleteLight, Args：Light_name。这里的类型type也就是,传递参数Light_name 输入rosservice call /gazebo/delete_light sun，这里的sun是参数名，使我们模拟场景中的唯一光源太阳。操作完成后可以看到场景中的光线消失。 可以看到终端的回传信息：success: True和sun successfully deleted 这就是双向通信的信息反馈，通知操作已经成功完成。 2. srv 类似msg文件，srv文件是用来描述服务（service）数据类型的，service通信的数据格式定义在*.srv中。它声明了一个服务的通信格式，包括请求(request)和响应（reply）两部分，中间用---隔开，用到的数据格式由*.msg文件定义。最终编译时需要修改package.xml和CMakeLists.txt文件 2.1. srv示例 以msgs_demo/srv/DetectHuman.srv服务为例，DetectHuman.srv服务取自OpenNI的人体检测ROS软件包，是用来查询当前深度摄像头中的人体姿态和关节数的。 bool start_detect --- my_pkg/HumanPose[] pose_data ---上面的内容是请求方需要发送的数据，即请求的格式 bool格式的数据，是否开始检测 ---下面的内容是服务提供方返回的数据，应答数据 my_pkg/HumanPose[]可变长度数组，pose_data的每个元素都是该人的姿态，数据格式定义在*.msg文件中 2.2. rossrv命令 rossrv 命令 作用 rossrv show 显示服务描述 rossrv list 列出所有服务 rossrv md5 显示服务md5sum rossrv package 列出包中的服务 rossrv packages 列出包含服务的包 "},"ROS/Action.html":{"url":"ROS/Action.html","title":"Action","keywords":"","body":"Action actionlib是ROS中一个很重要的库，类似service通信机制，actionlib也是一种请求响应机制的通信方式，actionlib主要弥补了service通信的一个不足，就是当机器人执行一个长时间的任务时，假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，致使通信受阻。当service通信不能很好的完成任务时候，actionlib则可以比较适合实现长时间的通信过程，actionlib通信过程可以随时被查看过程进度，也可以终止请求，这样的一个特性，使得它在一些特别的机制中拥有很高的效率。 1. Action通信原理 Action的工作原理是client-server模式，也是一个双向的通信模式。通信双方在ROS Action Protocol下通过消息进行数据的交流通信。client和server为用户提供一个简单的API来请求目标（在客户端）或通过函数调用和回调来执行目标（在服务器端）。 相当于Action是对机器人之间的通信进行了一层封装，对于用户程序而言，相当于是直接通信，但是实际上是用户程序和Action Client和Action Server通信 2. Action通信规范 通信过程中涉及到的消息类型 goal 由Action Client向Action Server发送用于设定动作需要用到的相关参数，比如运动目标点的坐标，速度等参数的设定 cancel Action执行的过程中，可以随时由Action Client向Action Server发送取消命令来终止动作任务 status 由Action Server向Action Client发送服务端当前的状态 restult 由Action Server向Action Client发送整个Action的执行结果，这个结果只会发送一次 feedback 由Action Server向Action Client在Action执行过程中的数据，比如执行进度、机器人运动过程中的坐标，可周期性发送 3. action *.action文件和*.srv文件类似，由---对各个部分进行分隔，*.action文件由三部分组成，分别是goal，result和feedback 3.1. action示例 以一个洗碗机的洗碗任务为例说明，goal部分是洗碗机的ID，在请求洗碗任务的时候需要指定洗碗机ID，result部分是最终洗碗的碗的数量，feedback部分是洗碗的进度，百分比表示，能在动作任务执行过程中随时汇报任务进度 # Define the goal uint32 dishwasher_id # Specify which dishwasher we want to use --- # Define the result uint32 total_dishes_cleaned --- # Define a feedback message float32 percent_complete "},"ROS/Parameter-server.html":{"url":"ROS/Parameter-server.html","title":"Parameter server","keywords":"","body":"Parameter Server 1. 简介 参数服务器是节点存储参数的地方、用于配置参数，全局共享参数。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。参数服务器维护着一个字典，用来存放各个节点的参数和配置信息，它是一种相对静态的通信方式 2. 维护方式 参数服务器中的字典可通过三种方式维护 命令行 launch文件 Node节点源码 2.1. 命令行方式 主要是通过使用rosparam命令来管理 rosparam 命令 作用 rosparam list 列出参数名称 rosparam get param_key 显示参数 rosparam set param_key param_value 设置参数 rosparam delete 删除参数 rosparam load file_name 从文件加载参数 rosparam dump file_name 保存参数到文件 在使用load和dump命令时的文件使用yaml格式 name:'Zhangsan' age:20 gender:'M' score:{Chinese:80,Math:90} score_history:[85,82,88,90] 参考YAML 语言教程 2.2. launch文件 launch文件中有很多标签，而与参数服务器相关的标签只有两个，一个是，另一个是。其中标签只能设置一个参数 通过脚本执行结果设置的值 这里的robot_description的value是用xacro.py执行robot.xacro文件之后的结果，再在启动urdf_spawner节点时的启动参数中加入robot_description这个参数 通过设置 这里标签的作用相当于使用命令行rosparm load xbot2_control.yaml加载yaml文件 直接设置的值 2.3. Node节点源码 通过roscpp或者rospy中提供的相关API直接在节点源码中维护参数的值 "},"ROS/roscpp.html":{"url":"ROS/roscpp.html","title":"roscpp","keywords":"","body":"roscpp 1. Client Library简介 ROS为机器人开发者们提供了不同语言的编程接口，比如C++接口叫做roscpp，Python接口叫做rospy，Java接口叫做rosjava。这些接口都可以用来创建topic、service、param，实现ROS的通信功能。Clinet Lirary有点类似开发中的Helper Class，把一些常用的基本功能做了封装。 从开发客户端库的角度看，一个客户端库，至少需要能够包括master注册、名称管理、消息收发等功能。这样才能给开发者提供对ROS通信架构进行配置的方法。 2. roscpp简介 roscpp相当于一个C++库，这个库包括了ROS节点的各种功能实现，roscpp位于/opt/ros/kinetic之下，用C++实现了ROS通信。在ROS中，C++的代码是通过catkin这个编译系统（扩展的CMake）来进行编译构建的。我们创建一个CMake工程，在其中include了roscpp等ROS的libraries，这样就可以在工程中使用ROS提供的函数了。 这个文件里包含了所有roscpp相关的头文件 #include roscpp包含的几个部分如下 ros::init_options命名空间包含节点初始化等功能性的函数 包含ros::init()初始化函数，有三个重载，在使用ROS系统相关功能之前必须调用这个函数 ros::NodeHandle类，句柄主要用来实现和topic、service、param等交互的公共接口 ros::master命名空间包含从master查询信息的函数 ros::this_node命名空间包含查询这个node的函数 ros::service命名空间包含查询服务的函数 ros::param命名空间包含查询参数服务器的函数，而不需要用到NodeHandle ros::names命名空间包含处理ROS图资源名称的函数 关于命名空间的详细解释参考官方wiki "},"ROS/init以及NodeHandle.html":{"url":"ROS/init以及NodeHandle.html","title":"init以及NodeHandle","keywords":"","body":"init以及NodeHandle 1. 节点初始化 ROS程序和其他Cpp程序的主要区别在于 它调用了ros::init()函数，完成了ROS节点的初始化，节点名称等信息 创建了ros::NodeHandle对象，通过这个节点句柄完成ROS通信的一些功能，比如创建Publisher和Subscriber等 句柄（Handle）的概念类似于this指针，NodeHandle相当于是对节点资源的描述，有了这个句柄就可以操作节点的具体功能实现 1.1. ros::init() 函数有三种重载 ROSCPP_DECL void init(int &argc, char **argv, const std::string& name, uint32_t options = 0); ROSCPP_DECL void init(const M_string& remappings, const std::string& name, uint32_t options = 0); ROSCPP_DECL void init(const VP_string& remapping_args, const std::string& name, uint32_t options = 0); argc argv是系统传入参数，在终端运行程序的时候传入 name是节点名字，字符串类型，节点名字需要在同一个ROS系统中保持唯一；如果出现重名，之前的节点会被关闭 options可以设置对节点的具体操作，默认值0，因此在调用的时候可以不指定该参数，具体取值为InitOption枚举体。 当ROS系统中有多个功能相同的节点的时候，可以使用匿名节点，options参数设置为ros::init_options::AnonymousName，在创建节点的时候ROS系统会自动在节点名后加随机数来保证ROS系统中的节点名字唯一 enum InitOption { /** * Don't install a SIGINT handler. You should install your own SIGINT handler in this * case, to ensure that the node gets shutdown correctly when it exits. */ NoSigintHandler = 1 ros::init()函数主要功能是 network::init(remappings); master::init(remappings); this_node::init(name, remappings, options); file_log::init(remappings); param::init(remappings); 参考ROS程序的初始化 1.2. NodeHandle NodeHandle是Node的句柄，用来对当前节点进行各种操作。在ROS中，NodeHandle是一个定义好的类，通过include，我们可以创建这个类，以及使用它的成员函数。各种类型的通信都需要用NodeHandle来创建完成 //创建话题的publisher ros::Publisher advertise(const string &topic, uint32_t queue_size, bool latch=false); //第一个参数为发布话题的名称 //第二个是消息队列的最大长度，如果发布的消息超过这个长度而没有被接收，那么就的消息就会出队。通常设为一个较小的数即可。 //第三个参数是是否锁存。某些话题并不是会以某个频率发布，比如 /map 这个topic，只有在初次订阅或者地图更新这两种情况下，/map才会发布消息。这里就用到了锁存。 //创建话题的subscriber ros::Subscriber subscribe(const string &topic, uint32_t queue_size, void(*)(M)); //第一个参数是订阅话题的名称 //第二个参数是订阅队列的长度，如果受到的消息都没来得及处理，那么新消息入队，旧消息就会出队 //第三个参数是回调函数指针，指向回调函数来处理接收到的消息 //创建服务的server，提供服务 ros::ServiceServer advertiseService(const string &service, bool(*srv_func)(Mreq &, Mres &)); //第一个参数是service名称 //第二个参数是服务函数的指针，指向服务函数。指向的函数应该有两个参数，分别接受请求和响应。 //创建服务的client ros::ServiceClient serviceClient(const string &service_name, bool persistent=false); //第一个函数式service名称 //第二个参数用于设置服务的连接是否持续，如果为true，client将会保持与远程主机的连接，这样后续的请求会快一些。通常我们设为flase //查询某个参数的值 bool getParam(const string &key, std::string &s); bool getParam (const std::string &key, double &d) const； bool getParam (const std::string &key, int &i) const； //从参数服务器上获取key对应的值，已重载了多个类型 //给参数赋值 void setParam (const std::string &key, const std::string &s) const； void setParam (const std::string &key, const char *s) const; void setParam (const std::string &key, int i) const; //给key对应的val赋值，重载了多个类型的val 2. 节点关闭 通常我们要关闭一个节点可以直接在终端上按Ctrl+C，系统会自动触发SIGINT句柄来关闭这个进程。 你也可以通过调用ros::shutdown()来手动关闭节点，但通常我们很少这样做。默认情况下终端中使用Ctrl+C，最终会调用ros::shutdown()，对于一些在退出时需要其他操作的节点，也可以自定义退出的操作，具体参考ROS节点的初始化及退出详解 #include int main(int argc, char** argv) { ros::init(argc, argv, \"your_node_name\"); ros::NodeHandle nh; //....节点功能 //.... ros::spin();//用于触发topic、service的响应队列 return 0; } "},"ROS/topic-in-roscpp.html":{"url":"ROS/topic-in-roscpp.html","title":"topic in roscpp","keywords":"","body":"topic in roscpp topic和msg相关解释 以topic_demo为例，自定义一个gps类型的消息（包括x, y, state），一个节点以一定频率模拟发布gps信息，另一个节点进行消息接收并计算出当前位置与原点(0, 0)的欧氏距离 1. 创建消息 新建topic_demo/msg/gps.msg文件 float32 x # x坐标 float32 y # y坐标 string state # 工作状态 程序中对消息的操作方法类似于对结构体的操作。 2. 创建节点 2.1. 消息发布节点 topic_demo/src/talker.cpp文件 #include #include int main(int argc, char **argv) { //用于解析ROS参数，第三个参数为本节点名 ros::init(argc, argv, \"talker\"); //实例化句柄，初始化node ros::NodeHandle nh; //自定义gps msg topic_demo::gps msg; msg.x = 1.0; msg.y = 1.0; msg.state = \"working\"; //创建publisher ros::Publisher pub = nh.advertise(\"gps_info\", 1); //定义发布的频率 ros::Rate loop_rate(1.0); //循环发布msg while (ros::ok()) { //以指数增长，每隔1秒更新一次 msg.x *= 1.03; msg.y *= 1.01; ROS_INFO(\"Talker: GPS: x = %f, y = %f \", msg.x ,msg.y); //以1Hz的频率发布msg pub.publish(msg); //根据前面定义的频率, sleep 1s loop_rate.sleep();//根据前面的定义的loop_rate,设置1s的暂停 } return 0; } 节点句柄的advertise函数是模板函数，因此在创建ros::Publisher对象时需要指定消息类型为topic_demo::gps，指定pub的发布主题为gps_info，发送队列大小为1 topic_demo::gps这个消息的命名空间为topic_demo的原因是CMakeLists.txt中定义的项目名是topic_demo 2.2. 消息接收节点 2.2.1. topic_demo/src/listener.cpp文件 #include #include #include void gpsCallback(const topic_demo::gps::ConstPtr &msg) { //计算离原点(0,0)的距离 std_msgs::Float32 distance; distance.data = sqrt(pow(msg->x,2)+pow(msg->y,2)); //float distance = sqrt(pow(msg->x,2)+pow(msg->y,2)); ROS_INFO(\"Listener: Distance to origin = %f, state: %s\",distance.data,msg->state.c_str()); } int main(int argc, char **argv) { ros::init(argc, argv, \"listener\"); ros::NodeHandle n; ros::Subscriber sub = n.subscribe(\"gps_info\", 1, gpsCallback); //ros::spin()用于调用所有可触发的回调函数。将进入循环，不会返回，类似于在循环里反复调用ros::spinOnce()。 ros::spin(); return 0; } 在新建ros::Subscriber对象的时候需要指定主题名、接收队列大小、回调函数的函数指针，这里的gpsCallback函数是回调函数的函数指针，只有sub收到消息的时候才会调用该函数。 具体去触发回调函数的命令就是ros::spin()，它会反复的查看有没有消息来，如果有就会让回调函数去处理。若只指定了callback函数，而不进行ros::spin()或者ros::spinOnce()最终也回调函数不会生效 2.2.2. 消息队列处理 Subscriber接收到消息，实际上是先把消息放到一个队列中去。队列的长度在Subscriber构建的时候设置好了。当有spin函数执行，就会去处理消息队列中队首的消息。 spin方法 阻塞/非阻塞 单线程/多线程 ros::spin() 阻塞 单线程 ros::spinOnce() 非阻塞 单线程 ros::MultiThreadedSpin() 阻塞 多线程 ros::AsyncMultiThreadedSpin() 非阻塞 多线程 阻塞类的spin函数执行的时候相当于程序进入了一个死循环，一直检查是否有新的消息入队，消息的处理通过回调函数来执行，因此正常情况下在阻塞类的spin函数之后的代码不会执行。 单线程与多线程的消息处理示意图如下 3. 项目结构文件 3.1. topic_demo/CMakeLists.txt文件 cmake_minimum_required(VERSION 2.8.3) project(topic_demo) find_package(catkin REQUIRED COMPONENTS roscpp std_msgs message_generation ) add_message_files(FILES gps.msg ) generate_messages(DEPENDENCIES std_msgs ) add_executable(talker src/talker.cpp) #生成可执行文件talker # add_dependencies(talker topic_demo_generate_messages_cpp) add_dependencies(talker ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) # 表明在编译talker前，必须先生编译完成自定义消息 # 必须添加add_dependencies，否则找不到自定义的msg产生的头文件 # 表明在编译talker前，必须先生编译完成自定义消息 target_link_libraries(talker ${catkin_LIBRARIES}) #链接 add_executable(listener src/listener.cpp ) #声称可执行文件listener add_dependencies(listener ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(listener ${catkin_LIBRARIES})#链接 ROS的消息的格式即msg文件是ROS自行定义的，并不是Cpp的标准，因此需要依赖message_generation功能包来将gps.msg文件“编译”成符合Cpp标准的形式的结构体、头文件等 消息中用到的float32和string并不是Cpp的标准格式，而是ROS系统提供的格式，因此需要依赖std_msgs包 generate_messages()是用来生成msg的，如果没有这行，在源程序中会找不到gps.h，也就是没有生成消息结构体 参考ROS 机器人技术 - 解析 CMakeList.txt 文件 3.2. topic_demo/package.xml文件 topic_demo 0.1.0 This package topic_demo someone mit catkin roscpp std_msgs message_generation message_runtime 在编译的时候需要用到message_generation依赖 在节点运行的时候需要用到message_runtime依赖，提供消息运行时需要的依赖 xml文件的必填项参考package.xml "},"ROS/service-in-roscpp.html":{"url":"ROS/service-in-roscpp.html","title":"service in roscpp","keywords":"","body":"service in roscpp Service和srv相关解释 以service_demo为例，定义Greeting.srv服务，接收姓名和年龄，返回一个字符串。一个节点发出服务请求，另一个节点提供服务，返回问候语 1. 创建服务 1.1. Greeting.srv文件 string name #短横线上边部分是服务请求的数据 int32 age --- #短横线下面是服务回传的内容。 string feedback 对于Greeting.srv而言，最终也被编译成Greeting结构体，在service_demo命名空间下 服务的两部分Request和Response是两个结构体，并且被嵌套在Greeting结构体下 2. 创建节点 2.1. server节点 service_demo/src/server.cpp文件 # include \"ros/ros.h\" # include \"service_demo/Greeting.h\" # include \"string\" // 定义请求处理函数 bool handle_function(service_demo::Greeting::Request &req, service_demo::Greeting::Response &res) { // 此处我们对请求直接输出 ROS_INFO(\"Request from %s with age %d \", req.name.c_str(), req.age); // 返回一个反馈，将response设置为\"...\" res.feedback = \"Hi \" + req.name + \". I'm server!\"; return true; } int main(int argc, char **argv) { // 初始化节点，命名为\"greetings_server\" ros::init(argc, argv, \"greetings_server\"); // 定义service的server端，service名称为“greetings”，收到request请求之后传递给handle_function进行处理 ros::NodeHandle nh; ros::ServiceServer service = nh.advertiseService(\"greetings\", handle_function); // 调用可 ros::spin(); return 0; } 服务端对外提供服务，通过nh句柄创建service，advertiseService()有两个参数，服务名和处理函数 当server节点收到服务请求时会调用handle_function() handle_function()的两个参数是Greeting的Request和Response两部分的引用，返回值是布尔型，是否成功执行 需要调用ros::spin();进行消息队列处理 2.2. client节点 service_demo/src/client.cpp文件 # include \"ros/ros.h\" # include \"service_demo/Greeting.h\" int main(int argc, char **argv) { // 初始化，节点命名为\"greetings_client\" ros::init(argc, argv, \"greetings_client\"); // 定义service客户端，service名字为“greetings”，service类型为service_demo ros::NodeHandle nh; ros::ServiceClient client = nh.serviceClient(\"greetings\"); // 实例化srv，设置其request消息的内容，这里request包含两个变量，name和age，见Greeting.srv service_demo::Greeting srv; srv.request.name = \"HAN\"; srv.request.age = 20; if (client.call(srv)) { // 注意我们的response部分中的内容只包含一个变量response，另，注意将其转变成字符串 ROS_INFO(\"Response from server: %s\", srv.response.feedback.c_str()); } else { ROS_ERROR(\"Failed to call service Service_demo\"); return 1; } return 0; } 通过nh句柄创建ros::ServiceClient对象的时候需要指定服务结构体和服务名，这里说的服务名是server节点在创建服务的时候起的名字 通过client.call()请求服务，参数为service_demo::Greeting的实例 srv.response.feedback是string类对象，在输出时通过c_str()成员函数转换为字符数组。参考C++中c_str()函数的用法 3. 项目结构文件 3.1. CMakeLists.txt cmake_minimum_required(VERSION 2.8.3) project(service_demo) find_package(catkin REQUIRED COMPONENTS roscpp std_msgs message_generation # 需要添加的地方 ) add_service_files( FILES Greeting.srv ) generate_messages(DEPENDENCIES std_msgs ) include_directories( include ${catkin_INCLUDE_DIRS} ) add_executable(server src/server.cpp) add_dependencies(server ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(server ${catkin_LIBRARIES}) add_executable(client src/client.cpp) add_dependencies(client ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(client ${catkin_LIBRARIES}) 和消息一样，新建服务也需要generate_messages()否则在代码中greeting.h头文件会报错 3.2. packages.xml service_demo 0.1.0 This package service_demo someone mit catkin roscpp std_msgs message_generation message_runtime "},"ROS/param-in-roscpp.html":{"url":"ROS/param-in-roscpp.html","title":"param in roscpp","keywords":"","body":"param in roscpp Parameter server 相关解释 roscpp为参数服务器的维护提供了两套api ros::param命名空间下的函数 ros::NodeHandle类的成员函数 1. param_demo param_demo/src/param.cpp文件 #include int main(int argc, char **argv){ ros::init(argc, argv, \"param_demo\"); ros::NodeHandle nh; int parameter1, parameter2, parameter3, parameter4, parameter5; //Get Param的三种方法 //ros::param::get()获取参数“param1”的value，写入到parameter1上 bool ifget1 = ros::param::get(\"param1\", parameter1); //ros::NodeHandle::getParam()获取参数 bool ifget2 = nh.getParam(\"param2\",parameter2); //如果get不到指定的param，它可以给parameter3指定一个默认值(如33333) nh.param(\"param3\", parameter3, 33333); if(ifget1) ROS_INFO(\"Get param1 = %d\", parameter1); else ROS_WARN(\"Didn't retrieve param1\"); if(ifget2) ROS_INFO(\"Get param2 = %d\", parameter2); else ROS_WARN(\"Didn't retrieve param2\"); if(nh.hasParam(\"param3\")) ROS_INFO(\"Get param3 = %d\", parameter3); else ROS_WARN(\"Didn't retrieve param3\"); //Set Param的两种方法 //ros::param::set()设置参数 parameter4 = 4; ros::param::set(\"param4\", parameter4); //ros::NodeHandle::setParam()设置参数 parameter5 = 5; nh.setParam(\"param5\",parameter5); ROS_INFO(\"Param4 is set to be %d\", parameter4); ROS_INFO(\"Param5 is set to be %d\", parameter5); //Check Param的两种方法 //ros::NodeHandle::hasParam() bool ifparam5 = nh.hasParam(\"param5\"); //ros::param::has() bool ifparam6 = ros::param::has(\"param6\"); if(ifparam5) ROS_INFO(\"Param5 exists\"); else ROS_INFO(\"Param5 doesn't exist\"); if(ifparam6) ROS_INFO(\"Param6 exists\"); else ROS_INFO(\"Param6 doesn't exist\"); //Delete Param的两种方法 //ros::NodeHandle::deleteParam() bool ifdeleted5 = nh.deleteParam(\"param5\"); //ros::param::del() bool ifdeleted6 = ros::param::del(\"param6\"); if(ifdeleted5) ROS_INFO(\"Param5 deleted\"); else ROS_INFO(\"Param5 not deleted\"); if(ifdeleted6) ROS_INFO(\"Param6 deleted\"); else ROS_INFO(\"Param6 not deleted\"); ros::Rate rate(0.3); while(ros::ok()){ int parameter = 0; ROS_INFO(\"=============Loop==============\"); //roscpp中尚未有ros::param::getallparams()之类的方法 if(ros::param::get(\"param1\", parameter)) ROS_INFO(\"parameter param1 = %d\", parameter); if(ros::param::get(\"param2\", parameter)) ROS_INFO(\"parameter param2 = %d\", parameter); if(ros::param::get(\"param3\", parameter)) ROS_INFO(\"parameter param3 = %d\", parameter); if(ros::param::get(\"param4\", parameter)) ROS_INFO(\"parameter param4 = %d\", parameter); if(ros::param::get(\"param5\", parameter)) ROS_INFO(\"parameter param5 = %d\", parameter); if(ros::param::get(\"param6\", parameter)) ROS_INFO(\"parameter param6 = %d\", parameter); rate.sleep(); } } param_demo/launch/param_demo_cpp.launch文件 param3: 3 param4: 4 param5: 5 2. 运行结果 执行rosrun param_demo param_demo的结果如下 [ WARN] [1611930965.096364533]: Didn't retrieve param1 [ WARN] [1611930965.096428485]: Didn't retrieve param2 [ WARN] [1611930965.097569665]: Didn't retrieve param3 [ INFO] [1611930965.099216747]: Param4 is set to be 4 [ INFO] [1611930965.099250417]: Param5 is set to be 5 [ INFO] [1611930965.100457062]: Param5 exists [ INFO] [1611930965.100498410]: Param6 doesn't exist [ INFO] [1611930965.102516533]: Param5 deleted [ INFO] [1611930965.102558813]: Param6 not deleted [ INFO] [1611930965.102579994]: =============Loop============== [ INFO] [1611930965.104550994]: parameter param4 = 4 [ INFO] [1611930968.438369688]: =============Loop============== [ INFO] [1611930968.441288282]: parameter param4 = 4 param1 2定义在launch文件中，直接通过rosrun打开节点的话，没有加载launch文件中对这几个参数的定义，所以节点无法读取参数 param3 读取的时候参数服务器中并没有这个参数，但是针对param3的读取方法是nh.param(\"param3\", parameter3, 33333);，这个参数的第三个变量是默认值，因此如若参数服务器中没有param3这个参数，会给parameter3变量赋默认值33333 template bool param(const std::string& param_name, T& param_val, const T& default_val) const { if (hasParam(param_name)) { if (getParam(param_name, param_val)) { return true; } } param_val = default_val; return false; } 执行roslaunch param_demo param_demo_cpp.launch的结果如下 process[param_demo-1]: started with pid [29494] [ INFO] [1611929812.346775227]: Get param1 = 1 [ INFO] [1611929812.346835230]: Get param2 = 2 [ INFO] [1611929812.347514679]: Get param3 = 3 [ INFO] [1611929812.349519691]: Param4 is set to be 4 [ INFO] [1611929812.349576397]: Param5 is set to be 5 [ INFO] [1611929812.351273386]: Param5 exists [ INFO] [1611929812.351307720]: Param6 doesn't exist [ INFO] [1611929812.353115211]: Param5 deleted [ INFO] [1611929812.353152792]: Param6 not deleted [ INFO] [1611929812.353196434]: =============Loop============== [ INFO] [1611929812.354020600]: parameter param1 = 1 [ INFO] [1611929812.354780836]: parameter param2 = 2 [ INFO] [1611929812.355424684]: parameter param3 = 3 [ INFO] [1611929812.356337908]: parameter param4 = 4 [ INFO] [1611929815.688232581]: =============Loop============== [ INFO] [1611929815.689976152]: parameter param1 = 1 [ INFO] [1611929815.691289476]: parameter param2 = 2 [ INFO] [1611929815.692041662]: parameter param3 = 3 [ INFO] [1611929815.692681417]: parameter param4 = 4 "},"ROS/命名空间.html":{"url":"ROS/命名空间.html","title":"命名空间","keywords":"","body":"命名空间 1. 名称（Names） 在ROS系统中的一个对象就是一个图（也称计算图computation graph）以下都可以称为图 Nodes: A node is an executable that uses ROS to communicate with other nodes. Messages: ROS data type used when subscribing or publishing to a topic. Topics: Nodes can publish messages to a topic as well as subscribe to a topic to receive messages. Master: Name service for ROS (i.e. helps nodes find each other) rosout: ROS equivalent of stdout/stderr roscore: Master + rosout + parameter server (parameter server will be introduced later) 这些图的命名有一定的规则，图的名字是层级化的，由一系列命名空间构成，这样就可以保证名字的唯一性，在ROS中有4中不同的图资源名 base（基本名称） relative/name （相对名称） /global/name （全局名称） ~private/name （私有名称） 在默认的情况下，对于名字的解析是相对于节点的命名空间完成的 名称 解释 相对名称 相对名称的解析是依赖默认命名空间的。如默认命名空间为”/” 则名称“A/B”被解析为”/A/B”。 基本名称 基本名称是没有命名空间限定符的相对名称（即没有/号）。 全局名称 以“/”开头的名称称为全局名称，代表该名称属于全局命名空间。意思是在ROS系统的任何地方都可以使用。无论在ROS系统的任何地方它都以明确的意义。 私有名称 私有名称以”~”开头，它与相对图名称的区别是，它的解析不依赖与默认命名空间，而是依赖包名称。 作为一个开源的、分布式的机器人操作系统，众多开发者开发的包并不能保证所有定义的资源命名都不同，一旦含有相同的名称的资源的包在一个ROS网络中运行，就会发生冲突。因此，在实际的ROS网络中，各个节点、话题、消息和参数的名称必须是唯一的，不然就会发生冲突，这很容易理解。区分相同名字的资源的两种方法 给两个名字前加上定语，就是添加命名空间 给两个名字取个不同的别名，就是重映射 参考 ROS之命名空间 ROS学习 之 命名空间（NameSpace）、重映射（Remapping）、名称（Names） ROS的命名空间与重映射 2. param 在这一个launch文件中有两个名为serial的参数，但这两个参数值不同，使用不同作用域的NodeHandle句柄可以对这两个参数分别读写 #include int main(int argc, char* argv[]) { int serial_number = -1;//serial_number初始化 ros::init(argc, argv, \"name_demo\");//node初始化 /*创建命名空间*/ //n 是全局命名空间 ros::NodeHandle n; //nh 是局部命名空间 ros::NodeHandle nh(\"~\"); //提取全局命名空间下的参数serial n.getParam(\"serial\", serial_number); //在全局命名空间下，要提取全局命名空间下的参数，直接写参数名 ROS_INFO(\"n.getParam(\\\"serial\\\", serial_number); --- global_Serial was %d\", serial_number); nh.getParam(\"/serial\", serial_number); //在局部命名空间下，要提取全局命名空间下的参数，需要添加“/” ROS_INFO(\"nh.getParam(\\\"/serial\\\", serial_number); --- local_to_global_Serial was %d\", serial_number); std::cout 在实例化NodeHandle句柄的时候会ros::NodeHandle n;和ros::NodeHandle nh(\"~\");有两种方式，这就区分出了全局命名空间和局部命名空间 roslaunch name_demo demo.launch执行结果 process[name_demo-1]: started with pid [7424] [ INFO] [1611980559.624305272]: n.getParam(\"serial\", serial_number); --- global_Serial was 5 [ INFO] [1611980559.625404705]: nh.getParam(\"/serial\", serial_number); --- local_to_global_Serial was 5 -------------------------------------------- [ INFO] [1611980559.626021242]: n.getParam(\"name_demo/serial\", serial_number); --- global_to_local_Serial was 10 [ INFO] [1611980559.626655962]: nh.getParam(\"serial\", serial_number); --- local_Serial was 10 3. topic ros::init(argc, argv, \"listener\"); ros::NodeHandle n(); ros::NodeHandle nh1(\"~\"); ros::NodeHandle nh2(\"~foo\"); ros::Subscriber sub = n.subscribe(\"gps_info\", ...); ros::Subscriber sub1 = nh1.subscribe(\"gps_info\", ...); ros::Subscriber sub2 = nh2.subscribe(\"gps_info\", ...); rostopic list的执行结果如下 /gps_info /listener/foo/gps_info /listener/gps_info /rosout /rosout_agg n句柄在创建的时候没有指定命名空间，所以默认为全局命名空间，因此sub订阅的话题是/gps_info nh1句柄在创建的时候指定私有命名空间，所以使用nh1句柄进行的操作都是在/listener命名空间下的，因此sub订阅的话题是/listener/gps_info nh2句柄在创建的时候指定~foo命名空间，所以使用nh2句柄进行的操作都是在/listener/foo命名空间下的，因此sub订阅的话题是/listener/foo/gps_info 很明显这三个topic虽然在订阅的时候名字都是gps_info，但实际上这是三个不同的topic "},"ROS/roscpp时钟.html":{"url":"ROS/roscpp时钟.html","title":"roscpp时钟","keywords":"","body":"时钟 1. Time与Duration 在ROS里面对于机器人的控制会经常使用到关于时间的功能，设定程序等待时间、设定定时器等。roscpp提供了两种时间表示方法 时刻ros::Time 时间ros::Duration Time和Duration都由秒和纳秒组成。表示方法为 int32 sec int32 nsec 在使用这两种功能时需要引用相应的头文件#include 和#include ros::Time begin = ros::Time::now(); //获取当前时间 ros::Time at_some_time1(5, 20000000); //5.2s ros::Time at_some_time2(5.2) //同上，重载了float类型和两个uint类型的构造函数 ros::Duration one_hour(60 * 60, 0); //1h double secs1 = at_some_time1.toSec();//将Time转为double型时间 double secs2 = one_hour.toSec();//将Duration转为double型时间 时间和持续时间算术运算 1 hour + 1 hour = 2 hours (duration + duration = duration) 2 hours - 1 hour = 1 hour (duration - duration = duration) Today + 1 day = tomorrow (time + duration = time) Today - tomorrow = -1 day (time - time = duration) Today + tomorrow = error (time + time is undefined) ros::Time t1 = ros::Time::now() - ros::Duration(5.5); //t1是5.5s前的时刻，Time加减Duration返回都是Time ros::Time t2 = ros::Time::now() + ros::Duration(3.3); //t2是当前时刻往后推3.3s的时刻 ros::Duration d1 = t2 - t1; //从t1到t2的时长，两个Time相减返回Duration类型 ros::Duration d2 = d1 -ros::Duration(0,300); //两个Duration相减，还是Duration 2. Sleeping 和 Rates bool ros::Duration::sleep()可以设置延迟一段时间，比如 ros::Duration(0.5).sleep(); //用Duration对象的sleep方法休眠 ros::Duration one_second(1, 0); one_second.sleep(); //休眠1秒 ros::Rate类可以设置频率 ros::Rate r(10); // 10 hz while (ros::ok()) { // ... do some work ... r.sleep(); } 3. Timer Rate的作用是指定一个频率，与之类似的是ROS中的定时器Timer，它是通过设定回调函数和触发时间来实现某些动作的反复执行，就和传统意义上的定时器功能一致 ros::Timer是一个类，使用时添加#include \"ros/ros.h\"即可，定时器也是需要通过使用节点句柄来创建 void callback1(const ros::TimerEvent&) { ROS_INFO(\"Callback 1 triggered\"); } void callback2(const ros::TimerEvent&) { ROS_INFO(\"Callback 2 triggered\"); } int main(int argc, char **argv) { ros::init(argc, argv, \"talker\"); ros::NodeHandle n; ros::Timer timer1 = n.createTimer(ros::Duration(0.1), callback1); //timer1每0.1s触发一次callback1函数 ros::Timer timer2 = n.createTimer(ros::Duration(1.0), callback2); //timer2每1.0s触发一次callback2函数 ros::spin(); //千万别忘了spin，只有spin了才能真正去触发回调函数 return 0; } 回调函数中的TimerEvent结构体 struct TimerEvent { Time last_expected; /// "},"ROS/日志和异常.html":{"url":"ROS/日志和异常.html","title":"日志和异常","keywords":"","body":"日志和异常 1. 日志 ROS系统中的日志系统是基于topic的，所有的日志信息都输出到/rosout话题上，rosout本身也是一个节点，负责处理ROS系统中的所有日志信息，会在启动master的时候自动启动 ROS的日志分为5个等级 DEBUG INFO WARN ERROR FATAL 用法类似printf()函数，支持格式化输出 ROS_DEBUG(\"The velocity is %f\", vel); ROS_WARN(\"Warn: the use is deprecated.\"); ROS_FATAL(\"Cannot start this node.\"); ... 关于日志详细介绍参考ROS与C++入门教程-Logging(日志) 2. 异常 roscpp所有的异常都继承基类ros::Exception，roscpp中有两种异常类型，当有以下两种错误时，就会抛出异常： 当无效的基础名称传给ros::init(),通常是名称中有/,就会触发 ros::InvalidNodeNameException 当无效名称传给了roscpp ros::InvalidNameExcaption "},"ROS/rospy.html":{"url":"ROS/rospy.html","title":"rospy","keywords":"","body":"rospy rospy是Python版本的ROS客户端库，提供了Python编程需要的接口，可以认为rospy就是一个Python的模块(Module)。这个模块位于/opt/ros/kineetic/lib/python2.7/dist-packages/rospy之中。 rospy包含的功能与roscpp相似，都有关于node、topic、service、param、time相关的操作。rospy没有一个NodeHandle，像创建publisher、subscriber等操作都被直接封装成了rospy中的函数或类，调用起来简单直观。 ROS中绝大多数基本指令，例如rostopic, roslaunch都是用python开发的，简单轻巧。 1. rospy代码组织形式 对于一些小体量的代码，直接把*.py文件放到src/script/目录下即可 robot_sim_demo ├── CMakeLists.txt ├── package.xml ... └── scripts └── robot_keyboard_teleop.py 对于一些体量较大的项目，在src下建立一个与你的package同名的路径，其中存放__init__.py以及你的模块文件 robot_sim_demo ├── CMakeLists.txt ├── package.xml ... ├── scripts │ └── robot_keyboard_teleop.py └── src └── robot_sim_demo ├── a.py ├── b.py └── __init__.py __init__.py可以将其所在目录变为一个python包，可以在其他的*.py文件中import这个包，即可使用这个包的功能代码。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。 参考Python init.py作用详解 2. init和node相关 参考init以及NodeHandle 返回值 方法 作用 rospy.init_node(name, argv=None, anonymous=False) 注册和初始化node MasterProxy rospy.get_master() 获取master的句柄 bool rospy.is_shutdown() 节点是否关闭 rospy.on_shutdown(fn) 在节点关闭时调用fn函数 str get_node_uri() 返回节点的URI str get_name() 返回本节点的全名 str get_namespace() 返回本节点的名字空间 3. topic in rospy 参考topic in roscpp learn_topic/src/scripts/py-listener.py #!/usr/bin/env python #coding=utf-8 import rospy import math from learn_topic.msg import gps # 回调函数输入的应该是msg def callback(gps): distance = math.sqrt(math.pow(gps.x, 2)+math.pow(gps.y, 2)) rospy.loginfo('Listener: GPS: distance=%f, state=%s', distance, gps.state) def listener(): rospy.init_node('pylistener', anonymous=True) # Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型，第三个参数是回调函数的名称 rospy.Subscriber('gps_info', gps, callback) rospy.spin() if __name__ == '__main__': listener() learn_topic/src/scripts/py-talker.py #!/usr/bin/env python #coding=utf-8 import rospy #倒入自定义的数据类型 from learn_topic.msg import gps def talker(): #Publisher 函数第一个参数是话题名称，第二个参数是数据类型，现在就是我们定义的msg，最后一个是缓冲区的大小 pub = rospy.Publisher('gps_info', gps , queue_size=10) rospy.init_node('pytalker', anonymous=True) #更新频率是1hz rate = rospy.Rate(1) x=1.0 y=2.0 state='working' while not rospy.is_shutdown(): #计算距离 rospy.loginfo('Talker: GPS: x=%f ,y= %f',x,y) pub.publish(gps(state,x,y)) x=1.03*x y=1.01*y rate.sleep() if __name__ == '__main__': talker() rospy和roscpp，对于消息（*.msg）的定义都是相同的，都需要在CMakeLists.txt和package.xml添加相应的依赖，但是又有所不同。 如果package中只包含python代码，则CMakeLists.txt中不需要使用add_executable()，仅添加相应的msg、rospy等依赖包即可 对于scripts/目录下的脚本文件需要有可执行的权限chmod +x *.py添加执行权限。如果没有执行权限，rosrun无法运行 4. service in rospy 参考service in roscpp learn_service/src/sctipts/py-server.py #!/usr/bin/env python #coding=utf-8 import rospy from learn_service.srv import * def handle_function(req): rospy.loginfo( 'Request from %s with age %d', req.name, req.age) return GreetingResponse(\"Hi %s. I' server!\"%req.name) def server_srv(): rospy.init_node(\"greetings_server\") s = rospy.Service(\"greetings\", Greeting, handle_function) rospy.loginfo(\"Ready to handle the request:\") # 阻塞程序结束 rospy.spin() if __name__==\"__main__\": server_srv() 在调用rospy.Service()函数的时候，回调函数handle的参数是*.srv文件中的request部分 handle_function()函数的返回值是*.srv文件中的respond部分，类型为对象，本例中的Greeting.srv文件中respond部分为一字符串 learn_service/src/sctipts/py-client.py #!/usr/bin/env python # coding:utf-8 import rospy from learn_service.srv import * def client_srv(): rospy.init_node('greetings_client') # 等待有可用的服务 \"greetings\" rospy.wait_for_service(\"greetings\") try: greetings_client = rospy.ServiceProxy(\"greetings\", Greeting) # resp = greetings_client(name=\"LI\", age=11) req = GreetingRequest(name=\"LI\", age=11) resp = greetings_client.call(req) # 打印处理结果，注意调用response的方法，类似于从resp对象中调取response属性 rospy.loginfo(\"Message From server:%s\"%resp.feedback) except rospy.ServiceException, e: rospy.logwarn(\"Service call failed: %s\"%e) if __name__==\"__main__\": client_srv() 在请求服务的时候greetings_client.call(req)请求参数req是Greeting.srv的request部分，函数的返回值是服务请求的respond 以下请求服务效果相同 greetings_client(name=\"HAN\", age=20) greetings_client.call(name=\"HAN\", age=20) 如代码所示构造GreetingRequest类，再传入greetings_client()方法 5. param 参考param in roscpp #!/usr/bin/env python # coding:utf-8 import rospy def param_demo(): rospy.init_node(\"param_demo\") rate = rospy.Rate(1) while(not rospy.is_shutdown()): parameter1 = rospy.get_param(\"/param1\") parameter2 = rospy.get_param(\"/param2\", default=222) rospy.loginfo('Get param1 = %d', parameter1) rospy.loginfo('Get param2 = %d', parameter2) rospy.delete_param('/param2') rospy.set_param('/param2',2) ifparam3 = rospy.has_param('/param3') if(ifparam3): rospy.loginfo('/param3 exists') else: rospy.loginfo('/param3 does not exist') params = rospy.get_param_names() rospy.loginfo('param list: %s', params) rate.sleep() if __name__==\"__main__\": param_demo() rospy比roscpp多了一个rospy.get_param_names()，能返回当前ros中的所有参数，返回值为python中的列表类型 6. 时钟 参考roscpp时钟 6.1. Time和Duration rospy中的关于时钟的操作和roscpp是一致的，都有Time、Duration和Rate三个类。 time_now1 = rospy.get_rostime() #当前时刻的Time对象 返回Time对象 time_now2 = rospy.Time.now() #同上 time_now3 = rospy.get_time() #得到当前时间，返回float 单位秒 time_4 = rospy.Time(5) #创建5s的时刻 duration = rospy.Duration(3*60) #创建3min时长 关于Time、Duration之间的加减法和类型转换，和roscpp中的完全一致，参考 6.2. sleep duration.sleep() #挂起 rospy.sleep(duration) #同上，这两种方式效果完全一致 loop_rate = Rate(5) #利用Rate来控制循环频率 while(rospy.is_shutdown()): loop_rate.sleep() #挂起，会考虑上次loop_rate.sleep的时间 6.3. Timer rospy里的定时器和roscpp中的也类似，只不过不是用句柄来创建，而是直接rospy.Timer(Duration, callback)，第一个参数是时长，第二个参数是回调函数。 def my_callback(event): print 'Timer called at ' + str(event.current_real) rospy.Timer(rospy.Duration(2), my_callback) #每2s触发一次callback函数 rospy.spin() 回调函数的传入值是TimerEvent类型，和roscpp中的TimerEvent结构体基本相同 class TimerEvent(object): \"\"\" Constructor. @param last_expected: in a perfect world, this is when the previous callback should have happened @type last_expected: rospy.Time @param last_real: when the callback actually happened @type last_real: rospy.Time @param current_expected: in a perfect world, this is when the current callback should have been called @type current_expected: rospy.Time @param last_duration: contains the duration of the last callback (end time minus start time) in seconds. Note that this is always in wall-clock time. @type last_duration: float \"\"\" def __init__(self, last_expected, last_real, current_expected, current_real, last_duration): self.last_expected = last_expected self.last_real = last_real self.current_expected = current_expected self.current_real = current_real self.last_duration = last_duration "},"ROS/TF-坐标转换.html":{"url":"ROS/TF-坐标转换.html","title":"TF 坐标转换","keywords":"","body":"TF 坐标转换 1. TF TF即TransForm，坐标转换，对于机器人实际应用而言，本身会涉及到多个坐标系，而机器人的实际运动需要的数据要在同一个坐标系中才能准确完成，这就涉及到了坐标转化。 比如对于一个机械手的应用场景而言，通过摄像头采集画面，判断被抓物体的位置，然后再通过机械手的运动将物体从一点移动到另一点。在这个场景中就涉及到了多个坐标系 摄像头采集到的画面中被抓物体的坐标是在这摄像头的坐标系中，这个是相对于这一帧图像的坐标 机械手的相对运动需要用到的坐标是在机械手的坐标系中，这个是相对于机械手的原始位置的坐标 对于摄像头、机械手、被抓物体而言，在真实世界中又有一个真实世界中的坐标，这个是相对于真实世界的坐标 对于被抓物体而言，在一个时刻，对于这个几个坐标系有完全不同的坐标，相当于一个物体有多个坐标。因此要能够顺利完成机器人的动作，就需要在使用坐标数据之前对这些坐标在不同的坐标系之间完成转换。 2. ROS中的TF 坐标变换包括了位置和姿态两个方面的变换，ROS中的tf是一个可以让用户随时记录多个坐标系的软件包。tf保持缓存的树形结构中的坐标系之间的关系，并且允许用户在任何期望的时间点在任何两个坐标系之间转换点，矢量等。 tf的定义可以看作是一种标准规范，它定义了坐标转换的数据格式和数据结构。tf的数据结构本质是树形的，因此称之为tf tree tf可以被看作是一个topic：/tf，该话题中的message保存的就是tf tree的数据结构，这个数据结构维护着整个ros系统的坐标转换关系。 tf也可以被看作是一个package，它也集成了一些工具，比如可视化、查看关节间的tf，debug tf等。tf的一些接口，就是roscpp和rospy里的API ROS中关于机器人的描述分为link（部件）和joint（关节），机器人的每个每个link都对应这个一个frame，即坐标系。下图为一个机器人的TF结构的抽象示意图 link和frame的概念是绑定的，一个机器人各个frame之间的关系就是由tf tree来维护的。 可以通过执行view_frames命令来生成frames.pdf来显示tf tree结构，如下图所示 每个圆圈代表一个frame，对应着机器人的一个link，任意两个frame之间都必须是联通的，如果出现某一环节的断裂，就会引发error系统报错．所以完整的tf tree不能有任何断层的地方。两个frame之间都有broadcaster，这里的broadcaster就是ROS中Topic通信中的publisher，当两个frame之间有相对运动了，它通过发布消息来沟通两个frame，完成信息交换、坐标转换 参考ROS中观察TF的工具 3. TF消息 TransformStampde.msg定义的消息就是broadcaster维持两个frame之间关系的数据结构。 TransformStamped.msg格式规范 std_mags/Header header uint32 seq time stamp string frame_id string child_frame_id geometry_msgs/Transform transform geometry_msgs/Vector3 translation float64 x float64 y float64 z geometry_msgs/Quaternion rotation float64 x float64 y flaot64 z float64 w header中定义了序号、时间戳、frame名字 child_frame_id定义的是子坐标系，即当前坐标系要与那个坐标系进行坐标转换 geometry_msgs/Transform定义的就是这两个frame之间作什么样的坐标变换，Vector3定义平移，Quaternion定义三维旋转 对于上图所示的坐标转换关系而言 header中frame_id为odom child_frame_id为Baselink_footprint transform的具体值即odom和Baselink_footprint坐标系之间的转换关系 "},"ROS/TF-in-roscpp.html":{"url":"ROS/TF-in-roscpp.html","title":"TF in roscpp","keywords":"","body":"TF in roscpp 数据类型 名称 数据类型 向量 tf::Vector3 点 tf::Point 四元数 tf::Quaternion 3*3矩阵（旋转矩阵） tf::Matrix3x3 位姿 tf::pose 变换 tf::Transform 带时间戳的以上类型 tf::Stamped 带时间戳的变换 tf::StampedTransform 这里说的tf::StampedTransform（带时间戳的变换）和TransformStampde.msg数据类型完全不同，tf::StampedTransform是c++的一个类，并不像TransformStampde.msg是ROS中的消息的概念，因此前者具有局限性，只能在c++中使用，而后者是依赖于ROS系统的一个数据结构，与语言无关，可以在C++、Python、Java等其他各种语言中使用该消息 数据转换 tf中与数据转化的数据都类型都包含在#include头文件中 函数名称 函数功能 tfScalar tf::Vector3::length() 计算向量的模 tfScalar tf::tfDot(const Vector3 &v1, const Vector3 &v2) 计算两个向量的点积 tfScalar tf::tfAngle(const tf::Vector3 &v1, const tf::Vector3 &v2) 计算两个向量的夹角 tfScalar tf::tfDistance2(const tf::Vector3 &v1, const tf::Vector3 &v2) 计算两个向量的距离 tf::Vector3 tf::tfCross(const tf::Vector3 &v1, const tf::Vector3 &v2) 计算两个向量的乘积 tf::Vector3 &tf::Vector3::normalize() 求与已知向量同方向的单位向量 void tf::Quaternion::setRPY(const tfScalar& yaw, const stScalar &pitch, const tfScalar &roll) 由欧拉角计算四元数 tf::Vector3 tf::Quaternion::getAxis() 由四元数得到旋转轴 void tf::Quaternion::setRotation(const tf::Vector3 &axis, const tfScalar &angle) 已知旋转轴和旋转角估计四元数 void tf::Matrix3x3::setRotation(const tf::Quaternion &q) 通过四元数得到旋转矩阵 void tf::Matrix3x3::getEulerYPR(tfScalar &yaw, tfScalar &pitch, tfScalar &roll) 由旋转矩阵求欧拉角 tfScalar为标量，通过typedef定义为double tf为命名空间，Vector3，Quaternion和Matrix3x3是三个类，上述函数有成员函数、有内普通内联函数 Demo #include #include int main(int argc, char **argv) { ros::init(argc, argv, \"coordinate_transformation\"); ros::NodeHandle node; std::cout 欧拉角转换为四元数demo #include #include int main(int argc, char **argv) { ros::init(argc, argv, \"Euler2Quaternion\"); ros::NodeHandle node; geometry_msgs::Quaternion q; double roll, pitch, yaw; while (ros::ok()) { //输入一个相对原点的位置 std::cout > roll >> pitch >> yaw; //输入欧拉角，转化成四元数在终端输出 q = tf::createQuaternionMsgFromRollPitchYaw(roll, pitch, yaw); //ROS_INFO(\"输出的四元数为：w=%d,x=%d,y=%d,z=%d\"，q.w,q.x,q.y,q.z); std::cout 四元数转换为欧拉角demo #include #include \"nav_msgs/Odometry.h\" #include int main(int argc, char **argv) { ros::init(argc, argv, \"Quaternion2Euler\"); ros::NodeHandle node; nav_msgs::Odometry position; tf::Quaternion RQ2; double roll, pitch, yaw; while (ros::ok()) { //输入一个相对原点的位置 std::cout > position.pose.pose.orientation.w >> position.pose.pose.orientation.x >> position.pose.pose.orientation.y >> position.pose.pose.orientation.z; //输入四元数，转化成欧拉角 tf::quaternionMsgToTF(position.pose.pose.orientation, RQ2); // tf::Vector3 m_vector3; 方法2 // m_vector3=RQ2.getAxis(); tf::Matrix3x3(RQ2).getRPY(roll, pitch, yaw); std::cout "},"Linux/Linux.html":{"url":"Linux/Linux.html","title":"Linux","keywords":"","body":"Linux "},"Linux/RZG2L-GPT.html":{"url":"Linux/RZG2L-GPT.html","title":"RZG2L-GPT","keywords":"","body":"RZG2L General PWM Timer (GPT) 1. overview 2. 出厂源码 3. cpg reset报错 4. 双通道同时输出 4.1. 设备树 4.2. 测试 4.3. 驱动 1. overview This LSI(Large Scale Integration) has a general purpose PWM timer (GPT) composed of 8 channels of 32-bit timer (GPT32E). 这里提到的channel和驱动源码中提到的channel_A,channel_B不是一个概念 这里的channel指不同定时器，可以独立设置周期、占空比 驱动中的channel_A,channel_B指一个定时器的两个通道，只可设置占空比，AB通道的周期相同 2. 出厂源码 目前用的 https://github.com/renesas-rz/rz_linux-cip/tree/rzg2l-cip41 drivers/pwm/gpt-rzg2l.c static int rzg2l_gpt_probe(struct platform_device *pdev) 设备树和驱动匹配之后会执行probe，其中有关于channel_A,channel_B的描述，但是没有both_AB 这个版本的驱动不支持AB两个通道同时输出 参考 https://raw.githubusercontent.com/renesas-rz/rz_linux-cip/rzg2l-cip54/drivers/pwm/gpt-rzg2l.c 修改 3. cpg reset报错 gpt3和gpt6同时打开，内核启动阶段会报错failed to get cpg reset [root@okg2l ~ ]# dmesg |grep gpt [ 0.090055] gpt-rzg2l 10048300.gpt: RZ/G2L GPT Driver probed [ 0.090361] rzg2l_gpt_probe+0x90/0x378 [ 0.090409] rzg2l_gpt_driver_init+0x18/0x20 [ 0.090453] gpt-rzg2l 10048600.gpt: failed to get cpg reset [ 0.090506] gpt-rzg2l: probe of 10048600.gpt failed with error -16 错误-16 #define EBUSY 16 /* Device or resource busy */ 在drivers/pwm/gpt-rzg2l.c的rzg2l_gpt_probe函数中可以看到关于cpg的配置信息 在probe过程中，需要申请rstc，即复位控制器资源，但是，只有第一次gpt3能成功获取，第二次gpt6就不能再获取这个资源 而从实验现象看，只需要复位一次，因此，对于产生错误的情况不return，继续执行 static int rzg2l_gpt_probe(struct platform_device *pdev) { ... rzg2l_gpt->rstc = devm_reset_control_get(&pdev->dev, NULL); if (IS_ERR(rzg2l_gpt->rstc)) { dev_err(δpdev->dev, \"failed to get cpg reset\\n\"); // return PTR_ERR(rzg2l_gpt->rstc); } ... } 详细分析 4. 双通道同时输出 4.1. 设备树 &pinctrl{ gpt6_pins: gpt6 { groups = \"gpt6_a_a\", \"gpt6_b_a\"; function = \"gpt6\"; }; }; &gpt6 { pinctrl-0 = ; pinctrl-names = \"default\"; channel=\"both_AB\"; status = \"okay\"; }; 4.2. 测试 pwm在文件系统中的接口 确认pwmchip，根据软链接指向，pwmchip1对应gpt6 ls -al /sys/class/pwm 修改周期，单位ns echo 0 > /sys/class/pwm/pwmchip1/export echo 1000000 > /sys/class/pwm/pwmchip1/pwm0/period echo 1 > /sys/class/pwm/pwmchip1/pwm0/enable 修改占空比，修改channel_A的占空比，单位ns，要小于period echo 800000 > /sys/class/pwm/pwmchip1/device/buffA0 echo 200000 > /sys/class/pwm/pwmchip1/device/buffB0 4.3. 驱动 在文件系统中添加接口 static ssize_t buffA0_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) static ssize_t buffA0_show(struct device *dev, struct device_attribute *attr, char *buf) static DEVICE_ATTR_RW(buffA0); static struct attribute *buffer_attrs[] = { &dev_attr_buffA0.attr, ... } 使用 /sys 文件系统访问 Linux 内核 "},"Linux/RZG2L-IPC.html":{"url":"Linux/RZG2L-IPC.html","title":"RZG2L-IPC","keywords":"","body":"RZG2L Inter-processor communication 1. 异构多核通信 1.1. 数据传递 1.2. Remoteproc 1.3. RPMsg 1.4. OpenAMP 1.4.1. OpenAMP的应用场景 2. RZG2L方案整体架构 3. A55核 3.1. 初始化 3.2. 创建remoteproc 3.2.1. 对remoteproc初始化 3.2.2. 处理资源表 3.3. 创建RPMsg device 3.3.1. 创建virtio设备 3.3.2. 处理vr_info->shm.io 3.3.3. 初始化rpmsg_vdev 3.4. app 3.4.1. 构造payload 3.4.2. 创建endpoint 3.4.3. poll 4. CM33核 4.1. 构建项目 4.1.1. 项目结构 4.1.2. 配置功能 4.2. 关于SCIF 4.2.1. GPIO 4.2.2. SCIF 4.2.3. 关于printf 4.3. 关于链接 烧录 参考 1. 异构多核通信 多核CPU运行模式主要有以下三种： 非对称多处理（Asymmetric multiprocessing，AMP）每个CPU内核运行一个独立的操作系统或同一操作系统的独立实例（instantiation） 对称多处理（Symmetric multiprocessing，SMP）一个操作系统的实例可以同时管理所有CPU内核，且应用并不绑定某一个内核 混合多处理（Bound multiprocessing，BMP）一个操作系统的实例可以同时管理所有CPU内核，但每个应用被锁定于某个指定的核心 RZG2L有两个Cortex-A55@1.2GHz，一个Cortex-M33@200MH，分别运行Linux和Freertos，是AMP系统 1.1. 数据传递 划分一块内存，这块内存M33核和A55核都能够访问，作为共享内存，用来传输数据 使用中断来保证同步，通知对方存取数据 内存的管理由主核负责，在每个通信方向上都有两个缓冲区，分别是USED和AVAIL，这个缓冲区可以按照RPMsg中消息的格式分成一块一块链接形成一个环 1.2. Remoteproc Remoteproc主要功能就是对远程处理器的生命周期进行管理，即启动、停止远程处理器。例如A55核先启动之后，可以使用Remoteproc远程加载固件、远程启动M33核 1.3. RPMsg RPMsg是实现对远程处理器信息传递，基于VirtIO的消息总线，它允许内核驱动程序与系统上可用的远程处理器进行通信，同时，驱动程序可以根据需要公开适当的用户空间接口。一般来说会把对外接口封装成TTY设备。 1.4. OpenAMP OpenAMP包含两部分，libmetal和open_amp libmetal open_amp virtio 是network和disk device的虚拟化标准，用来管理共享内存 rpmsg remoteproc OpenAMP是Mentor Graphics与赛灵思公司为了使在AMP系统的设计中开发出的RTOS和裸机程序能够与开源Linux社区提供的接口进行互通讯，而共同通过的一个标准化的嵌入式多核框架。提供远程处理器生命周期管理、非对称多核通信等，主要是给RTOS或者裸机系统提供服务。也可以用于Linux用户空间中。 OpenAMP使用libmetal作为抽象层来访问设备、处理中断、共享内存。 1.4.1. OpenAMP的应用场景 1.4.1.1. RPMsg Implementation in Kernel Space Linux kernel space provides RPMsg and Remoteproc, but the RPU application requires Linux to load it in order to talk to the RPMsg counterpart in the Linux kernel. This is the Linux kernel RPMsg and Remoteproc implementation limitation. 1.4.1.2. OpenAMP RPMsg Implementation in Linux Userspace OpenAMP library can also be used in Linux userspace. In this configuration, the remote processor can run independently to the Linux host processor. 2. RZG2L方案整体架构 对于stm32mp157，他的M核使用了OpenAMP框架来提供remoteproc和rpmsg功能，在Linux端则是直接使用Liunx内核提供的相关功能 但是RZG2L的Linux端，没有使用Linux内核中的remoteproc和rpmsg，而是使用OpenAMP库实现Remoteproc，RPMsg，而且关于Remoteproc，没有用到远程加载firmware、远程启动内核相关功能 最底层是UIO/VFIO，由Linux内核提供 libmetal使用UIO/VFIO相关接口 open-amp依赖于libmetal，提供Remoteproc、RPMsg相关功能 最顶层的是应用程序，使用RPMsg相关接口完成核间通信 在M33核中，使用到了 Message Handling Unit (MHU) 提供Inter-Processor Interrupt General Timer (GTM) 用来Configures the tick for FreeRTOS. 3. A55核 在A55端程序，依赖libmetal.so.0.1.0和libopen_amp.so.0.1.0库，没有源码，只有库文件，在/opt/poky/3.1.5/sysroots/aarch64-poky-linux/usr/lib64/目录里。 3.1. 初始化 初始化libmetal，init_system(); metal_init(&metal_param); 3.2. 创建remoteproc platform_create_proc() 所谓创建remoteproc就是填充struct remoteproc结构体，这个结构体里有一个void *priv;私有数据 这里的私有数据是指struct remoteproc_priv，包含三部分 notify_id，用来区分不同的remoteproc mbx_chn_id，未知用途，代码中没有用到 struct vring_info *vr_info，这个结构体里是三个struct shm_info，描述了三块共享内存 rsc，对应设备树里42f00000.rsctbl，用来存放资源表 ctl，对应设备树里43000000.vring-ctl0，用途未知 shm，对应设备树里43200000.vring-shm0，用来传递数据 在OpenAMP的框架下编程，所以使用的是metal_allocate_memory(sizeof(struct remoteproc));为remoteproc指针申请内存 3.2.1. 对remoteproc初始化 remoteproc_init(rproc_inst, &rzg2_proc_ops, rproc_priv)，传入操作（rzg2_proc_ops），函数指针。 最终调用的是rzg2_proc_init() 首先是打开设备metal_device_open(ipi.bus_name, ipi.name, &dev); 类似linux中的操作模式，先open，再进行后续操作 open中主要是进行硬件配置、打开ipi设备，这里指的是10400000.mbox-uio metal_device_io_region() 使用的都是metal库的api，把这个设备看作是一块内存，映射到用户空间 返回的是一个struct metal_io_region *，是这块内存的物理地址、虚拟地址等相关信息 rzg2_enable_interrupt() 在这里设置中断相关的函数，处理核间通信时产生的中断信号，注册中断的回调函数等 init_memory_device() 把私有数据中的vring_info里面的内存填充上地址了，之前都是null vring_info的三个shm_info本质都是内存块，在metal框架下认为其都是设备；在设备树中描述的，就是设备 以其中vring_info->rsc为例 ret = metal_device_open(info->bus_name, info->name, &dev); 先打开设备42f00000.rsctbl info->io = metal_device_io_region(dev, 0x0U); 这一步就是获取 内存区块，类似一个操作句柄？ remoteproc_init_mem()初始化这块内存 remoteproc_add_mem()，把这块内存添加到remoteproc结构体，也就是说，把这块内存交由remoteproc管理， 3.2.2. 处理资源表 资源表是用来描述cm33都有哪些资源的，相当于cm33的自身属性，所以需要放到cm33的程序中，由CM33核的程序定义的，并存放在42f00000.rsctbl共享内存中 A55核想要使用cm33核，需要知道cm33有哪些功能，所以是在A55中读资源表。 需要先映射这段内存的物理地址到虚拟地址（MMU） rsc_table = remoteproc_mmap(rproc_inst, &pa, NULL, rsc_size, 0, NULL); 之后ret = remoteproc_set_rsc_table(rproc_inst, rsc_table, rsc_size);，解析资源表，并把数据保存到remoteproc中，这样a55就知道cm33有哪些资源可用了 3.3. 创建RPMsg device /** * struct rpmsg_virtio_device - representation of a rpmsg device based on virtio * @rdev: rpmsg device, first property in the struct * @vdev: pointer to the virtio device * @rvq: pointer to receive virtqueue * @svq: pointer to send virtqueue * @shbuf_io: pointer to the shared buffer I/O region * @shpool: pointer to the shared buffers pool * @endpoints: list of endpoints. */ struct rpmsg_virtio_device { struct rpmsg_device rdev; struct virtio_device *vdev; struct virtqueue *rvq; struct virtqueue *svq; struct metal_io_region *shbuf_io; struct rpmsg_virtio_shm_pool *shpool; }; struct rpmsg_device * platform_create_rpmsg_vdev(void *platform, unsigned int vdev_index, unsigned int role, void (*rst_cb)(struct virtio_device *vdev), rpmsg_ns_bind_cb ns_bind_cb); platform_create_rpmsg_vdev()；的返回值是struct rpmsg_device *，这个相当于基类指针，但是后续真正使用的时候，需要把他直接强制类型转换到struct rpmsg_virtio_device * 在rpmsg_virtio_device结构体中，第一个成员变量就是rpmsg_device，所以他们的地址是相同的，所以可以直接强制类型转换。 3.3.1. 创建virtio设备 /* remoteproc_create_virtio * * create virtio device, it returns pointer to the created virtio device. * * @rproc: pointer to the remoteproc instance * @vdev_id: virtio device ID * @role: virtio device role * @rst_cb: virtio device reset callback * * return pointer to the created virtio device, NULL for failure. */ struct virtio_device * remoteproc_create_virtio(struct remoteproc *rproc, int vdev_id, unsigned int role, void (*rst_cb)(struct virtio_device *vdev)); 3.3.1.1. 和G2L相悖的部分 RPMsg是基于virtio的messaging bus，允许本地处理器和远程处理器进行交流。它是用virtio vring在共享内存上发送和接收数据的。具体而言，vring是单向的，总共需要开两个实现双向传输，在两个处理器都能看到的内存空间上会开辟共享的buffer。使用IPI来通知处理器在共享内存中有待读取的数据。 /* * Channel direction and usage: * * ======== -------=============--- buf free--> || M33 || * || || || || * ||master|| -------=============----new msg --> ======= */ A55是master（VIRTIO_DEV_MASTER），CM33是slave（VIRTIO_DEV_SLAVE），但是目前只看到了一个virtio设备，所以上述说法，只能进行单向通信，但是目前好像是能双向通信， 或者说，之前对程序理解有误，就是在进行单向通信？ 或者是，再什么地方进行了另一个方向的virtio设备创建？ 或者是，这里说的virtio设备和上述的channel不是对应的，这里的virtio能进行双向通信？ 3.3.2. 处理vr_info->shm.io 在创建remoteproc的时候已经对私有数据中的vr_info->shm.io这个region初始化了，所以他代表的就是43200000.vring-shm0这块内存。 pa = metal_io_phys(prproc->vr_info->shm.io, 0x0U); //根据这一个整个的内存块和offset，计算出想要使用的物理地址。 shbuf_io = remoteproc_get_io_with_pa(rproc, pa); //根据物理地址，再转换到指向相应的内存struct metal_io_region * 这里经过转换是为了有些场景可能需要对这一大块内存region分块使用，所以需要根据offset确定真正用的region。但是这里是直接使用的一整块，offset为0，最后prproc->vr_info->shm.io和shbuf_io指向的内容是相同的。 LPRINTF(\"initializing rpmsg shared buffer pool\\n\"); shbuf = metal_io_phys_to_virt(shbuf_io, pa); //把物理地址转换到虚拟地址（MMU转换），在linux中对内存的访问都需要经过MMU映射 len = metal_io_region_size(prproc->vr_info->shm.io); rpmsg_virtio_init_shm_pool(&shpool, shbuf, len); //填充 shpool 结构体，包含内存起始地址、可用大小、总大小。 处理之后得到一个struct rpmsg_virtio_shm_pool共享内存池，之后的核间数据传输都需要通过shpool传输。 /** * struct rpmsg_virtio_shm_pool - shared memory pool used for rpmsg buffers * @get_buffer: function to get buffer from the pool * @base: base address of the memory pool * @avail: available memory size * @size: total pool size */ struct rpmsg_virtio_shm_pool { void *base; size_t avail; size_t size; }; struct rpmsg_virtio_shm_pool shpool; 3.3.3. 初始化rpmsg_vdev rpmsg_init_vdev(rpmsg_vdev, vdev, ns_bind_cb, shbuf_io, &shpool); //初始化一个rpmsg virtio device设备 这里的ns_bind_cb是一个回调函数，负责根据name server创建end point，但是目前通过它创建的ept都不能正常通信。 3.4. app 在这里进行真正数据发送相关内容，在这之前已经完成了准备工作，建立了核间通信的前提。rpmsg通信是一个udp-like通信协议，到这相当于建立了两个设备之间的ip连接，接下需要根据不同app选择相应端口(endpoint) 3.4.1. 构造payload 申请消息体需要的内存，这里直接根据rpmsg_virtio_get_buffer_size()申请空间。 /** * rpmsg_virtio_get_buffer_size - get rpmsg virtio buffer size * * @rdev - pointer to the rpmsg device * * @return - next available buffer size for text, negative value for failure */ int rpmsg_virtio_get_buffer_size(struct rpmsg_device *rdev); 柔性数组 3.4.2. 创建endpoint /* Create RPMsg endpoint */ if (svcno == 0) { svc_name = (char *)CFG_RPMSG_SVC_NAME0; } else { svc_name = (char *)CFG_RPMSG_SVC_NAME1; } ret = rpmsg_create_ept(&rp_ept, rdev, svc_name, APP_EPT_ADDR, RPMSG_ADDR_ANY, rpmsg_service_cb0, rpmsg_service_unbind); rp_ept，创建的ept rdev，struct rpmsg_device *结构体指针，rpmsg设备 svc_name端口的名字，通信双方两个端口名字应当一致 APP_EPT_ADDR是本机的地址，即A55端地址。rpmsg通信需要双方都创建ept，目的地址源地址要互相对应。 RPMSG_ADDR_ANY是对方地址，这里是0xFFFFFFFF 当目的地址是0xFFFFFFFF时，会根据名字在channel内进行广播，查询对方的地址，类似arp 当源地址是0xFFFFFFFF时，会自动根据端口使用情况选择一个没有占用的端口，类似dhcp 这里说地址不准确，通信的时候，A55核和CM33核端程序地址都设置为0，也能正常通信，用端口比较好 rpmsg设备对应一条建立好的ip数据通道（相当于建立了路由关系） src和dest对应 端口号 rpmsg设备加上src和dest，组合之后，类似socket rpmsg_service_cb0，接收到数据之后的回调函数 rpmsg_service_unbind0，通信结束后的回调函数 3.4.3. poll while (!is_rpmsg_ept_ready(&rp_ept)) //等待源地址和目的地址都自动获取成功 platform_poll(priv); //poll机制 //priv是之前创建的remoteproc结构体指针 LPRINTF(\"RPMSG service has created.\\n\"); for (i = 0, size = pi.min; i num = i; i_payload->size = size; /* Mark the data buffer. */ memset(&(i_payload->data[0]), 0xA5, size); LPRINTF(\"sending payload number %lu of size %lu\\n\", i_payload->num, (2 * sizeof(unsigned long)) + size); ret = rpmsg_send(&rp_ept, i_payload, (2 * sizeof(unsigned long)) + size); //发送 if (ret 4. CM33核 4.1. 构建项目 CM33端程序运行在FreeRTOS之上的，使用了OpenAMP框架作为多核通信基础 运行两个task，分别是blinky_thread_entry.c和MainTask_entry.c，控制LED和通信 代码框架由e2stdio生成 4.1.1. 项目结构 Debug/ 编译过程中生成的中间文件、最终的elf文件、分段之后的程序 rzg/ arm/ arm内核启动文件 aws/ FreeRTOS相关文件 board/ 板子相关，这部分不会根据configuration.xml配置文档自动变化 rzg2l_smarc/board_leds.c 核心板的LED rzg2l_smarc/pin_data.c 引脚使用情况（SCIF） fsp/ 外设的驱动文件 linaro/ libmetal、open-amp rzg_cfg/ freertos等配置文件 rzg_gen/ 自动生成的代码框架，包含main.c script/ 链接脚本 src/ 用户代码 configuration.xml after_build.bat 4.1.2. 配置功能 打开configuration.xml文件之后，选择FSP Configuration视图即可配置项目 如图，可在New Stack添加相应功能，在属性面板中可以修改相关属性，保存之后Genetate Project Content生成修改后的项目。 rzg_gen/目录下的文件都是自动生成的，最好不要直接修改里面的文件，否则下一次Genetate Project Content之后会覆盖之前的修改。 自动生成的文件第一行有相关注释 /* generated main source file - do not edit */ 4.2. 关于SCIF 对于FreeRTOS而言，不像linux驱动框架那样有丰富的子系统，配置外设资源需要考虑的相对来说比较底层。 对于SCIF外设，需要从几个方面配置相关功能 SCIF对应的GPIO相关配置 SCIF的时钟、复位 SCIF功能的相关寄存器 4.2.1. GPIO GPIO的功能包括功能复用、电气属性、滤波等 volatile uint8_t * p_pmc; //模式选择，GPIO or Peripheral volatile uint32_t * p_iolh; //驱动能力 volatile uint32_t * p_sr; //设置压摆率 volatile uint32_t * p_pupd; //上、下拉 volatile uint32_t * p_filonoff; //数字噪声滤波 volatile uint32_t * p_filnum; volatile uint32_t * p_filclksel; volatile uint32_t * p_pfc; //复用功能选择 另外，Port Function Control Register (PFCm)寄存器有写保护 4.2.1.1. 歧路 开发板上SCIF2转换成了RS485电平，SCIF1是TTL电平，瑞萨官方提供的rzg2l_cm33_rpmsg_demo中使用的是SCIF2 在configuration.xml中改成SCIF1之后，默认rzg\\board\\rzg2l_smarc\\pin_data.c中设置的是SCIF2的引脚，没有自动修改，所以一直没有波形 typedef struct { ... union { __IOM uint16_t PM38; struct { __IOM uint8_t L; __IOM uint8_t H; } PM38_byte; struct { __IOM uint8_t PM38_0 : 2; __IOM uint8_t PM38_1 : 2; __IOM uint8_t PM38_2 : 2; uint8_t : 2; uint8_t : 8; } PM38_b; }; ... union { __IOM uint8_t PMC38; struct { __IOM uint8_t PMC38 : 3; uint8_t : 5; } PMC38_b; }; ... union { __IOM uint32_t PFC38; struct { __IOM uint16_t L; __IOM uint16_t H; } PFC38_hword; struct { __IOM uint8_t LL; __IOM uint8_t LH; __IOM uint8_t HL; __IOM uint8_t HH; } PFC38_byte; struct { __IOM uint8_t PFC38_0 : 3; uint8_t : 1; __IOM uint8_t PFC38_1 : 3; uint8_t : 1; __IOM uint8_t PFC38_2 : 3; uint8_t : 5; uint8_t : 8; uint8_t : 8; } PFC38_b; }; ... __IM uint8_t RESERVED314[3]; union { __IOM uint8_t PWPR; struct { uint8_t : 6; __IOM uint8_t PFCWE : 1; __IOM uint8_t BOWI : 1; } PWPR_b; }; ... } R_GPIO_Type; #define R_GPIO_BASE 0x41030010 #define R_GPIO ((R_GPIO_Type *) R_GPIO_BASE) R_GPIO->PMC38_b.PMC38 = R_GPIO->PMC38_b.PMC38 | 0x3; //P40_0 P40_1 Peripheral Function Mode //offset: 0x0238 R_GPIO->PWPR_b.BOWI = 0; while(R_GPIO->PWPR_b.BOWI != 0); R_GPIO->PWPR_b.PFCWE = 1; //PFC write en //0x3014 R_GPIO->PFC38_b.PFC38_0 = 1; //p40_0，复用功能1 // 0x04e0 R_GPIO->PFC38_b.PFC38_1 = 1; R_GPIO->PM38_b.PM38_0 = 2; //P40_0，TX，output // 0x0170 R_GPIO->PM38_b.PM38_1 = 1; //P40_1，RX，input 4.2.2. SCIF 驱动文件在rzg\\fsp\\src\\r_scif_uart\\r_scif_uart.c，里面有操作SCIF相关寄存器的操作 对于项目中设置使用的SCIF1，相关定义在rzg_gen\\hal_data.c中的const uart_instance_t g_uart1全局变量，设置了串口的属性、操作api等 src\\serial.c中的代码属于应用代码，对SCIF的驱动再进行封装 static void outbyte1(console_t console, char c) { flag_tend = 0; g_uart1.p_api->write(g_uart1.p_ctrl, &c, 1); while(flag_tend == 0) { __WFI(); } } void outbyte(console_t console, char c) { if (!xSerialPortInitialized) { g_uart1.p_api->open(g_uart1.p_ctrl, g_uart1.p_cfg); g_uart1.p_api->callbackSet(g_uart1.p_ctrl, uart_callback, NULL, NULL); xSerialPortInitialized = 1; } /* Standard practice to convert \\n to \\r\\n */ if (c == '\\n') outbyte1(console, '\\r'); outbyte1(console, c); } 4.2.3. 关于printf 瑞萨修改了mbed Microcontroller Library，通过mbed_minimal_formatted_string将数据格式化处理，调用outbyte()通过串口发送 /* * Modified by Renesas so functions pass a context down to outbyte(). * outbyte() is implemented elsewhere so that it can pass a context that our * serial output function. This is all done to allow us to create a printf_raw() * function that outputs immediately to the UART for emergency output such as an * abort. */ /** * @brief Parse formatted string and invoke write handlers based on type. * * @param buffer The buffer to write to, write to stdout if NULL. * @param[in] length The length of the buffer. * @param[in] format The formatted string. * @param[in] arguments The va_list arguments. * @param[in] console The method of char data control. * * @return Number of characters written. */ int mbed_minimal_formatted_string(char *buffer, size_t length, const char *format, va_list arguments, console_t console) 4.3. 关于链接 链接脚本在script\\fsp.ld CM33核的程序编译完成之后是rzg2l_cm33_rpmsg_demo.elf，需要经过after_build.bat处理 arm-none-eabi-objcopy -O binary -j .secure_vector %1.elf %1_secure_vector.bin arm-none-eabi-objcopy -O binary -j .non_secure_vector %1.elf %1_non_secure_vector.bin arm-none-eabi-objcopy -O binary -j .secure_code %1.elf %1_secure_code.bin arm-none-eabi-objcopy -O binary -j .non_secure_code -j .data %1.elf %1_non_secure_code.bin 烧录 烧录的时候只用到了secure_vector non_secure_vector secure_code non_secure_code这四个section，CM33核的程序是在uboot阶段加载并启动cm33核 分别把四段程序加载到相应位置 bin addr rzg2l_cm33_rpmsg_demo_non_secure_vector.bin 0x00010000 rzg2l_cm33_rpmsg_demo_secure_vector.bin 0x0001FF80 rzg2l_cm33_rpmsg_demo_non_secure_code.bin 0x40010000 rzg2l_cm33_rpmsg_demo_secure_code.bin 0x42EFF440 从内存卡中加载，uboot的shell中输入命令 dcache off mmc dev 1 fatload mmc 1:1 0x0001FF80 rzg2l_cm33_rpmsg_demo_secure_vector.bin fatload mmc 1:1 0x42EFF440 rzg2l_cm33_rpmsg_demo_secure_code.bin fatload mmc 1:1 0x00010000 rzg2l_cm33_rpmsg_demo_non_secure_vector.bin fatload mmc 1:1 0x40010000 rzg2l_cm33_rpmsg_demo_non_secure_code.bin cm33 start_debug 0x0001FF80 0x00010000 dcache on 从emmc中加载 dcache off ext4load mmc 0:1 0x0001FF80 boot/cm33/rzg2l_cm33_rpmsg_demo_secure_vector.bin ext4load mmc 0:1 0x42EFF440 boot/cm33/rzg2l_cm33_rpmsg_demo_secure_code.bin ext4load mmc 0:1 0x00010000 boot/cm33/rzg2l_cm33_rpmsg_demo_non_secure_vector.bin ext4load mmc 0:1 0x40010000 boot/cm33/rzg2l_cm33_rpmsg_demo_non_secure_code.bin cm33 start_debug 0x0001FF80 0x00010000 dcache on 设置环境变量，自动启动CM33内核，其中bin文件放在/boot/cm33/，从emmc中加载到指定地址，之后启动CM33 setenv name4cm33 rzg2l_cm33_rpmsg_demo setenv emmcloadcm33 'ext4load mmc 0:1 0x0001FF80 boot/cm33/${name4cm33}_secure_vector.bin;ext4load mmc 0:1 0x42EFF440 boot/cm33/${name4cm33}_secure_code.bin;ext4load mmc 0:1 0x00010000 boot/cm33/${name4cm33}_non_secure_vector.bin;ext4load mmc 0:1 0x40010000 boot/cm33/${name4cm33}_non_secure_code.bin;' setenv startcm33 'dcache off;run emmcloadcm33;cm33 start_debug 0x0001FF80 0x00010000;dcache on;' setenv bootcmd 'run startcm33;run bootcmd_check;run bootimage' saveenv 参考 Introduction_to_OpenAMPlib_v1.1a STM32MP157的Remoteproc和RPMsg框架 STM32MP157A和IPCC Linux UIO机制--用户空间I / O操作方法 RPMsg in Linux and OpenAMP Project - Xilinx Wiki UG1186 - Libmetal and OpenAMP User Guide (v2022.1) OpenAMP remoteproc wiki Rpmsg与Virtio介绍 RPMsg：协议简介 RZ/G2L and RZ/G2UL Group Multi-OS Package objcopy 介绍 "},"Linux/RZG2L-Camera.html":{"url":"Linux/RZG2L-Camera.html","title":"RZG2L-Camera","keywords":"","body":"RZG2L-Camera 1. 引言 1.1. 摄像头的数据传输流程如下 1.2. g2l开启摄像头 2. 硬件外设 2.1. csi 2.2. 35.2 Image Processing 2.3. 36. Image Scaling Unit (ISU) 3. v4l2 - media device 3.1. G2L 3.2. 数据传输模型 4. 驱动中关于cru的色彩空间转换 5. fltest_qt_camera 5.1. 设置cru最终输出的图像格式，对应cru->output_is_yuv 5.2. 设置cru输入的数据格式，对应cru->input_is_yuv 6. gstreamer 6.1. 测试 6.1.1. 最终输出源是waylandsink，输出RGB16能显示，输出RGB不能显示 6.1.2. 最终的输出源是autovideosink时，输出RGB和RGB16都能正常显示 6.1.3. 另外waylandsink支持NV12格式 7. 结论 参考 1. 引言 ov5645摄像头支持的输出模式，RAW RGB，RGB565/555/444，YUV422/420，YCbCr422 rzg2l的cpu手册中，35. Camera Data Receiving Unit (CRU)包含两部分 MIPI CSI-2 能从接收MIPI CSI格式的数据中分离video data部分，并送到Image Processing处理 Image Processing 这部分能从external Digital Parallel Interface或者MIPI CSI-2 block接收数据，并执行相应的图形处理 这里的external Digital Parallel Interface传输的数据是ITU656/Parallel ITU-R Recommendation BT.656，有时候也称为ITU656，是一个简单的数字视频协议，用于将未压缩的PAL或NTSC（525行或者625行）信号进行编码。 https://zh.m.wikipedia.org/zh-hans/BT.656 rzg2l的摄像头，能从mipi csi读入；也能从external Digital Parallel Interface读入，即并口摄像头 The image-processed data is temporarily stored in the FIFO and transferred to an external memory. 1.1. 摄像头的数据传输流程如下 ov5645部分 sensor读入数据，经过adc处理 image sensor processor处理 auto white balence, gamma, color space image output interface，经过FIFO，通过mipi发送出去 CRU的MIPI CSI-2部分 从MIPI CSI接口读到的数据包中分离出video data部分 CRU的Image Processing部分 将从MIPI CSI-2输入的数据放到内部FIFO中， 进行颜色空间转换等图像处理 将输出通过AXI bus传输到外部内存 用户空间通过共享内存读取摄像头数据 1.2. g2l开启摄像头 通过qt程序，fltest_qt_camera 疯狂掉帧，fps大概0.3吧，延迟巨大，大概4s 从摄像头读取的数据是yuv422格式的，经过软件转换为rgb格式再显示 命令行方式，gst-launch-1.0 v4l2src device=/dev/video0 io-mode=2 ! waylandsink window-x=0 window-y=0 window-width=1024 window-height=600 画面流畅 在gstreamer框架下直接显示画面，摄像头数据是yuv422，直接输出到waylandsink，也是yuv422格式。 但是一般LCD屏幕只能接收RGB数据，猜测这部分转换是在waylandsink中实现的，或者屏幕上有yuv转RGB的芯片？ 这两种方式都没有使用到Image Processing硬件，什么功能都没用。ICnMC寄存器控制各个功能 2. 硬件外设 Figure 35.1 Block Diagram of CRU 2.1. csi mipi csi，可以有4个lane，每个lane对应两根信号线（差分信号）。有一对差分时钟信号。ov5645，使用了2个lane，也就是，用两对差分信号传输数据，MDP0,MDN0,MDP1,MDN1 MIPI简介(三)——CSI-2 2.2. 35.2 Image Processing The image processing module is a data conversion module equipped with pixel color space conversion, LUT, pixel format conversion, etc 所以对于摄像头的色彩空间转换是由这部分的硬件完成的。 2.3. 36. Image Scaling Unit (ISU) The ISU is a module that reads out the image stored in the external DRAM, scale down image size, and outputs the reduced image into the DRAM. ISU also support a color format conversion and cropping image. 对应设备树中isum@10840000，但是根据compatible没有找到相应的驱动源码，这部分的驱动好像是没有？ cat /lib/modules/$(uname -r)/modules.builtin 查看编译进内核的驱动 cat /proc/modules 查看已经加载的驱动，同lsmod 好像ISU的驱动根本就没有？ 这里的ISU是独立于CRU的另一个外设，和CRU无关，只是根据手册中描述也有色彩空间转换功能。 3. v4l2 - media device media framework，提供实时的 pipeline 管理，pipeline 就理解为管道，想象一下水管，里面的水就是数据流，输入设备中的 csi->isp->video 就组成了一个 pipeline 线路。media framework 提供 pipeline 的开启、关停、效果控制、节点控制等功能。 media framework 其中一个目的是：在运行时状态下发现设备拓扑并对其进行配置。为了达到这个目的，media framework将 硬件设备抽象为一个个的entity，它们之间通过links连接。 entity：硬件设备模块抽象（类比电路板上面的各个元器件、芯片） pad：硬件设备端口抽象（类比元器件、芯片上面的管脚） link：硬件设备的连线抽象，link的两端是pad（类比元器件管脚之间的连线） #------------# #------------# | __|__ __|__ | | | | | link | | | | | | pad || pad | | | |__|__| |__|__| | | | | | | entity | | entity | #------------# #------------# 可以想象一下，如果各个 entity 之间需要建立连接的话，就需要在 pad 中存储 link 以及 entity 信息，link 中需要存储 pad 与 entity 信息，entity 里面需要存储 link 与 pad 信息，属于你中有我，我中有你的情况。 在v4l2框架下，需要注册一个v4l2_device，和若干个v4l2_subdev。所有设备都抽象为entity，这样就可以在media框架下通过/dev/media0进行控制了 V4L2框架-media device 3.1. G2L rzg2l手册中描述35. Camera Data Receiving Unit (CRU)包含两部分，35.1 MIPI CSI-2和35.2 Image Processing，而在实际代码中的名字有点出入。 设备树中的cru: video@10830000就是手册中的35.2 Image Processing，以下cru特指35.2 Image Processing，而非35. Camera Data Receiving Unit (CRU) 设备树中的csi2: csi2@10830400就是手册中的35.1 MIPI CSI-2 设备注册流程如下 G2L的csi2: csi2@10830400会注册一个v4l2_subdev设备 这个subdev主要功能是static int rzg2l_csi2_s_stream(struct v4l2_subdev *sd, int enable)控制视频流数据的开启与否 在drivers/media/platform/rzg2l-cru/rzg2l-csi2.c的static int rzg2l_csi2_probe(struct platform_device *pdev)函数中 v4l2_subdev_init(&priv->subdev, &rzg2l_csi2_subdev_ops); priv->subdev.entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER; 像素格式化功能，也就是在这进行yuv和rgb转换？ ret = v4l2_async_register_subdev(&priv->subdev);，异步注册subdev设备 这个并没有直接注册，而是把当前这个subdev加入到sd->async_list链表中，之后再异步注册 ov5645在i2c的 probe中也会注册一个v4l2_subdev设备 在drivers/media/i2c/ov5645.c的static int ov5645_probe(struct i2c_client *client, const struct i2c_device_id *id)函数中 v4l2_i2c_subdev_init(&ov5645->sd, client, &ov5645_subdev_ops); ov5645->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR; 传感器，也就是最原始的数据来源。这里设置的是uyvy格式 ret = v4l2_async_register_subdev(&ov5645->sd);异步注册 G2L的cru: video@10830000会注册一个v4l2_device设备 在drivers/media/platform/rzg2l-cru/rzg2l-core.c的static int rzg2l_cru_probe(struct platform_device *pdev) ret = rzg2l_cru_dma_register(cru, irq);注册dma，以及CRU相关配置 ret = v4l2_device_register(cru->dev, &cru->v4l2_dev); 注册v4l2_device设备 v4l2_device设备作为顶层管理者，管理众多v4l2_subdev ret = rzg2l_cru_mc_init(cru); ret = media_device_register(&group->mdev);注册media设备，向用户空间暴露/dev/media0接口 ret = rzg2l_cru_parallel_init(cru); ret = v4l2_async_notifier_register(&cru->v4l2_dev, &cru->notifier); 遍历链表，挨个注册之前添加到链表中的子设备。（drivers/media/v4l2-core/v4l2-async.c） 至此，一个v4l2_device设备，两个v4l2_subdev设备注册完。所有的v4l2_subdev都暴露一个/dev/v4l-subdev节点给用户空间；在cru注册时向用户空间暴露了一个/dev/media0节点 上述流程简要说是，csi，ov5645分别异步注册v4l2_subdev；cru在probe的时候，创建了/dev/media0节点，同时，扫描了v4l2框架下的v4l2_subdev，并进行了注册；同时，创建link，连接cru和csi 最后这个创建link连接cru和csi，是在v4l2框架中，所有设备都被抽象化为entity，这些entity之间通过link连接。而在G2L的CPU手册中，摄像头数据通过外部接口传入cpu之后，首先要通过csi处理，过滤出数据部分，之后交给cru进行图像处理。这个数据传输路径是在设计芯片的时候就确定了，所以csi连接cru是必经之路，所以直接在驱动中就创建了link，而不需要用户通过命令行再创建link。 通过加入entities链表的方式（每个设备都抽象为entity，加入），media_device保持了对所有的设备信息的查询和控制的能力，而该能力会通过media controller框架在用户空间创建meida设备节点，将这种能力暴露给用户进行控制。 通过media-ctl -d /dev/media0 -p可以查看所有的 media 框架下的设备信息，能看到之前注册的两个v4l2_subdev和一个v4l2_device 3.2. 数据传输模型 V4L2视频采集的基本流程 Linux V4L2子系统-videobuf2框架分析（三） 4. 驱动中关于cru的色彩空间转换 在drivers/media/platform/rzg2l-cru/rzg2l-dma.c中 根据if (cru->output_is_yuv == cru->input_is_yuv)判断是否开CRU的启色彩空间转换功能，两个bool output_is_yuv是根据switch (cru->format.pixelformat) { 判断的 在qt中是调用if (-1 == ioctl(fd, VIDIOC_S_FMT, &fmt)) {这个ioctl时设置的 对应在rzg2l-dma.c中是case V4L2_PIX_FMT_BGR24: 另外，根据CPU手册Table 35.13 Image Output Formats (2/2)输出格式为RGB888时，其实输出的格式对应为BGR，低字节为B，高字节为R 所以output_is_yuv值为0 input_is_yuv是根据switch (cru->mbus_code) { 判断的 在驱动中是case MEDIA_BUS_FMT_UYVY8_2X8: 所以input_is_yuv值为1 output_is_yuv和input_is_yuv不相等，所以会使用硬件，在这里会设置ICnDMR寄存器的控制字 rzg2l_cru_write(cru, ICnDMR, icndmr); 设置输出的格式，最终设置寄存器值 ICnDMR是寄存器地址偏移量 icndmr是控制字 5. fltest_qt_camera int VideoCapture::Init(int iscru)创建link，连接摄像头和csi int VideoCapture::LoopCapture() 从v4l2框架中获取内核空间中的摄像头数据，并显示 if (-1 == ioctl(fd, VIDIOC_DQBUF, &buf)) { 把数据放回缓存队列（相当于在用户空间释放内存，将这个空闲内存给到内核空间） convert_yuv_to_rgb_buffer((unsigned char *)buffers[buf.index].start[0],rgb, this->width, this->height); yuv422转rgb888，消耗算力 在label中显示图像 QImage *mage = new QImage(rgb, width, height, QImage::Format_RGB888); QImage resultimg = mage->scaled(img->size());将图像缩放到label控件的尺寸 img->setPixmap(QPixmap::fromImage(resultimg)); 在videocapture.h中#define BUFINFOR_NUM (6)可以设置队列的大小。 5.1. 设置cru最终输出的图像格式，对应cru->output_is_yuv 在int VideoCapture::Init(int iscru)中有设置输出的像素格式的ioctl，将输出格式改为BGR24，如下 fd = ::open(devname, O_RDWR | O_NONBLOCK, 0); if (fd width; fmt.fmt.pix.height = this->height; // fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV; //设置图像格式 fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_BGR24; //设置图像格式 'ov5645 0-003c':0 [fmt:UYVY8_2X8/1280x960 field:none] if (-1 == ioctl(fd, VIDIOC_S_FMT, &fmt)) { qDebug() 5.2. 设置cru输入的数据格式，对应cru->input_is_yuv cru的数据是从摄像头中获取的，经由csi处理获取到数据部分，创建link连接csi和cru 对应命令行开启摄像头中的media-ctl -d /dev/media0 -l \"'rzg2l_csi2 10830400.csi2':1 -> 'CRU output':0 [1]\" 在int VideoCapture::Init(int iscru)函数中 ret = media_parse_setup_links(media, \"'rzg2l_csi2 10830400.csi2':1 -> 'CRU output':0 [1]\"); if (ret) { qDebug() 在fltest_qt_camera中的下拉菜单选择的摄像头数据格式，格式为format UYVY2X8 640x480，在drivers/media/i2c/ov5645.c中会对摄像头数据格式进行匹配 ov5645的驱动中预设了几种数据格式，根据传入的参数匹配到一个最相似的格式。这里匹配到的是'ov5645 0-003c':0 [fmt:UYVY8_2X8/1280x960 field:none] 对应命令行开启摄像头中的media-ctl -d /dev/media0 -V \"'ov5645 0-003c':0 [fmt:UYVY8_2X8/1280x960 field:none]\" 在int VideoCapture::Init(int iscru)函数中 char formatstr[128]; snprintf(formatstr, 128, \"'ov5645 0-003c':0 [fmt:UYVY2X8/%dx%d]\", this->width, this->height); ret = v4l2_subdev_parse_setup_formats(media, formatstr); if (ret) { qDebug() 6. gstreamer 手册中测试方法 media-ctl -d /dev/media0 -l \"'rzg2l_csi2 10830400.csi2':1 -> 'CRU output':0 [1]\" media-ctl -d /dev/media0 -V \"'ov5645 0-003c':0 [fmt:UYVY8_2X8/1280x960 field:none]\" gst-launch-1.0 v4l2src device=/dev/video0 io-mode=2 ! waylandsink window-x=0 window-y=0 window-width=1024 window-height=600 当使用qt界面的程序的时候，qt程序cpu占用50%多 使用gst，最终输出是waylandsink，占用27% 当占用到50%，就会卡。基本可以判断waylandsink中使用到了硬件解码 6.1. 测试 videotestsrc源能生成测试视频 通过gst-inspect-1.0 waylandsink查询，waylansink支持RGB格式，但是 gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB16,width=1280,height=960 ! waylandsink window-x=0 window-y=0 window-width=1024 window-height=600 生成RGB565格式视频，输出到waylandsink，能正常显示 gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB,width=1280,height=960 ! waylandsink window-x=0 window-y=0 window-width=1024 window-height=600 生成RGB格式视频，不能显示 gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB16,width=1024,height=600 ! autovideosink gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB,width=1024,height=600 ! autovideosink 这两个都能正常显示 6.1.1. 最终输出源是waylandsink，输出RGB16能显示，输出RGB不能显示 root@okg2l /home/root$ gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB16,width=1280,height=960 ! waylandsink window-x=0 window-y=0 window-width=1024 window-height=600 Setting pipeline to PAUSED ... Pipeline is PREROLLING ... Pipeline is PREROLLED ... Setting pipeline to PLAYING ... New clock: GstSystemClock ^Chandling interrupt. Interrupt: Stopping pipeline ... Execution ended after 0:00:01.313004251 Setting pipeline to NULL ... Freeing pipeline ... root@okg2l /home/root$ gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB,width=1280,height=960 ! waylandsink window-x=0 window-y=0 window-width=1024 window-height=600 Setting pipeline to PAUSED ... Pipeline is PREROLLING ... ERROR: from element /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0: Internal data stream error. Additional debug info: ../gstreamer-1.16.3/libs/gst/base/gstbasesrc.c(3072): gst_base_src_loop (): /GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0: streaming stopped, reason not-negotiated (-4) ERROR: pipeline doesn't want to preroll. Setting pipeline to NULL ... Freeing pipeline ... 6.1.2. 最终的输出源是autovideosink时，输出RGB和RGB16都能正常显示 root@okg2l /home/root$ gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB16,width=1024,height=600 ! autovideosink Setting pipeline to PAUSED ... Pipeline is PREROLLING ... Got context from element 'autovideosink0': gst.gl.GLDisplay=context, gst.gl.GLDisplay=(GstGLDisplay)\"\\(GstGLDisplayWayland\\)\\ gldisplaywayland0\"; Pipeline is PREROLLED ... Setting pipeline to PLAYING ... New clock: GstSystemClock ^Chandling interrupt. Interrupt: Stopping pipeline ... Execution ended after 0:00:02.640105584 Setting pipeline to NULL ... Freeing pipeline ... root@okg2l /home/root$ gst-launch-1.0 videotestsrc ! video/x-raw,format=RGB,width=1024,height=600 ! autovideosink Setting pipeline to PAUSED ... Pipeline is PREROLLING ... Got context from element 'autovideosink0': gst.gl.GLDisplay=context, gst.gl.GLDisplay=(GstGLDisplay)\"\\(GstGLDisplayWayland\\)\\ gldisplaywayland0\"; Pipeline is PREROLLED ... Setting pipeline to PLAYING ... New clock: GstSystemClock ^Chandling interrupt. Interrupt: Stopping pipeline ... Execution ended after 0:00:02.082643126 Setting pipeline to NULL ... Freeing pipeline ... 当最后的输出节点设置为 autovideosink 会有输出 Got context from element 'autovideosink0': gst.gl.GLDisplay=context, gst.gl.GLDisplay=(GstGLDisplay)\"\\(GstGLDisplayWayland\\)\\ gldisplaywayland0\";可以看到，最终选择的是OpenGL绘制的窗口，最终使用的输出节点是 glimagesink，把最后的 autovideosink替换成glimagesink也可 这里又涉及到了OpenGL https://gstreamer.freedesktop.org/documentation/gl-wayland/gstgldisplay_wayland.html?gi-language=c https://gstreamer.freedesktop.org/documentation/gl/gstglcontext.html?gi-language=c 6.1.3. 另外waylandsink支持NV12格式 gst-launch-1.0 videotestsrc ! video/x-raw,format=NV12 ! waylandsink window-x=0 window-y=0 window-width=1024 window-height=600 成像质量差一点，但是能正常显示 所以，手册中命令行方式直接把摄像头图像输出到waylandsink，可能根本就没进行色彩空间转换？但是LCD屏幕只能接收RGB格式数据，那具体是在哪里转换的？可能问题的关键就在waylandsink吧 常用图像像素格式 NV12、NV21、I420、YV12、YUYV 7. 结论 瑞萨的驱动中包含cru进行色彩空间转换的相关功能，只要输出cru和输出cru的图像格式不一致，会自动开启cru相关转换功能 瑞萨手册中描述cru输出RGB，实际输出的格式是BGR，而目前QT版本不支持BGR格式的图片显示，所以需要在QT程序中进行红蓝转换，再显示 目前采用的测试方法，摄像头仍输出yuv422格式数据，经过cru进行图像转换到bgr888格式，再在qt里把r和b反转，再显示 对于qt程序中画面撕裂卡顿，全是因为CPU处理图像速度不够，对qt程序中频繁申请内存空间等代码优化之后，能稍微减缓一点 但是为什么通过top查看CPU占用只有50%多，而不是70%，80%甚至更多？ 可能受制于IO速度？ 那为什么使用waylandsink显示摄像头画面不卡？ 可能在软件层面没有进行色彩空间转换？LCD屏幕上有色彩空间转换相关的芯片？ 根据autovideosink的输出信息，猜测可能用到了OpenGL 当把摄像头数据直接输出到autovideosink，画面也会卡顿，qt中也会卡顿，所以猜测qt绘制窗口画面时也是用到了OpenGL 是不是还会和gpu有关系？ 对于摄像头的输出格式，在OV5645_CSP3_DS_1.11.PDF的第3页有描述，虽然手册中6.4 format description中描述了很多种格式，但是好像不是都支持 可以在drivers/media/i2c/ov5645.c文件开头的数组种修改摄像头的寄存器配置信息，但是尝试失败了 另外关于36. Image Scaling Unit (ISU)，根据手册描述，也有色彩空间转换功能，但是没有找到相关驱动，也就没有再深究 参考 深入浅出，快速弄明白 gst-launch-1.0 PIPELINE-DESCRIPTION 管道描述语法 深入学习Linux摄像头（二）v4l2驱动框架 select函数及fd_set介绍 camera_kernel之---media子系统（3） V4L2框架解析 Linux V4L2之camera Linux v4l2架构学习 END "},"Linux/Auth.html":{"url":"Linux/Auth.html","title":"Auth UID加密","keywords":"","body":"Auth 1. UID认证 2. eFuse/OTP 3. 加密算法 3.1. Hash 3.2. AES 3.3. 加盐(salt) 4. G2L加密 4.1. 加盐 4.2. sha256 4.3. AES 4.4. 烧写 5. 从抄板角度看 1. UID认证 UID（Unique ID）唯一ID，芯片的身份认证，UID认证的目的是为了知识产权保护，防止非法复制，从实施流程来看分两部分 出厂前写入密文信息 读取芯片的UID，通过一系列算法对UID加密得到密文A，保存在某存储介质中 程序启动前的认证 读取芯片的UID，通过相同的算法对UID加密得到密文B，读取某存储介质，得到密文C，对比B和C 2. eFuse/OTP eFuse(electronic Fuse)，电子熔丝，只能被写入1次，写入之后不可修改。 OTP（One Time Programmable memory），一次性编程 一般情况下芯片对eFuse空间分块，有一个寄存器控制eFuse区块的读写权限，因此，向eFuse中写入数据之后，再写入相应写保护位，即可保证数据不会被修改 3. 加密算法 3.1. Hash Hash（哈希、散列），是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。 简单来说就是任意长度的数据，通过哈希运算之后，得到一个固定长度的数据。这个过程是不可逆的。 散列函数有非常大的定义域，但是值域是有限的，因此肯定会存在某两个数据对应的hash值相同，即必然存在哈希碰撞。在密码学中，不一定要求数据完全无法被破解，只要保证破解的成本足够大即可。 目前常用的散列算法 算法名称 输出大小(bits) 内部大小 区块大小 长度大小 字符尺寸 碰撞情形 MD2 128 384 128 No 8 大多数 MD4 128 128 512 64 32 是 MD5 128 128 512 64 32 是 SHA-0 160 160 512 64 32 是 SHA-1 160 160 512 64 32 有缺陷 SHA-256/224 256/224 256 512 64 32 否 SHA-512/384 512/384 512 1024 128 64 否 MD5算法的破解，差分攻击，这种方法概括起来说是这样的：给定一个1024位的原文M1，加上一个特定的常数得到的新的明文M2。M1和M2的MD5码是一样的 Collisions for Hash Functions MD4, MD5, HAVAL-128 and RIPEMD. Xiaoyun Wang,Dengguo Feng,Xuejia Lai,et al. Rump Session of Crypto’04 E-print . 2004 3.2. AES 高级加密标准(Advanced Encryption Standard，缩写AES)，又称Rijndael加密法。 严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中两者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特；而Rijndael使用的密钥和区块长度均可以是128，192或256比特。加密过程中使用的密钥是由Rijndael密钥生成方案产生。 对称加密的一个特点就是，加密密钥和解密密钥相同，AES加密的密文可以通过密钥和解密算法得到明文。 密码学基础：AES加密算法 对称加密算法 - 廖雪峰 3.3. 加盐(salt) 盐（Salt），在密码学中，是指在散列之前将散列内容的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。 比如，对于明文Achipid 明文A经过sha256散列，得到密文Af503394b1380c6099e8c1b1f1e7acd971a49398eec7a0f827d747ad8353b7b78 chipid是很容易读到的内容，如果直接把密文A存到存储介质中，作为认证信息，很容易被猜到破解 对明文Achipid加盐123456，得到加盐后的明文Bchipid123456 明文B经过sha256散列，得到密文Bec1029d97540c3102f92f0c5658fcf9907a22a5979fe23308f7ef972ea465658 相对来说，加盐之后能更好防止被破解 4. G2L加密 对密文信息的认证放在BL2阶段，BL2不开源。 4.1. 加盐 typedef union { struct { uint8_t chipid[8]; char salt[8]; char chipid_HEX_ASCII[16]; }st; uint8_t raw[32]; }data; chipid为芯片的UID，共8字节 slat为固定的字符串， chipid_HEX_ASCII为chipid的hex表示的ascii 一个字节用2位16进制数表示 高位补0 4.2. sha256 加盐后的明文A共32字节，通过sha256算法计算摘要，得到32字节密文A 4.3. AES 密文A作为AES的密钥，同时把密文A作为AES的密文，进行解密计算，得到明文B 这里虽然从AES算法流程看最后的计算结果是明文，但是从实际上整个Auth过程看是密文，因为这个明文B和明文A并不相同 4.4. 烧写 目前G2L不支持OTP，将数据存放到核心板的一片eeprom。eeprom内部存储默认值为0xff，直接存放的话，明文B在里面会很扎眼。 全片写入随机数，随机数是生成的伪随机数列，以明文B的一段为seed static long holdrand; void auth_set_seed(unsigned int seed) { holdrand = (long)seed; } int auth_random(void) { return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff); } 将明文B写入eeprom的某个特定位置，比如0x10; 5. 从抄板角度看 芯片通电后执行片内ROM，之后根据boot拨码启动，对于G2L来说，执行spiflash中的Uboot的BL2部分代码。 目前可以得到的信息 BL2的二进制文件 eeprom的全片内容 芯片的chipid 除BL2部分之外的全部源码，包括uboot和kernel 如果抄了一个板，即使把eeprom中的内容全部复制到新板，那chipID肯定是不同的，所以计算出来的密文肯定和eeprom中的不同，也不能通过认证，相当于eeprom和CPU绑定了。 想要绕过认证，只能通过分析BL2部分代码，所以好像只要没有B2L部分的代码，那就没有办法复制。 "},"Linux/Linux-device-model.html":{"url":"Linux/Linux-device-model.html","title":"Linux-device-model","keywords":"","body":"Linux设备模型 1. 前言 1.1. 核心思想 2. 相关数据结构 3. 驱动开发基本步骤 4. probe 5. platform驱动模型 6. i2c驱动模型 6.1. 数据结构 6.1.1. bus 6.1.2. driver 6.1.3. device 6.2. 注册流程 6.2.1. bus注册 6.2.2. i2c_driver向内核注册 6.2.3. 构建i2c_client 1. 前言 Linux设备模型（Driver Model）主要包含Bus、Class、Device、Device_driver四个概念，设备模型将硬件设备归纳、分类，然后抽象出一套标准的数据结构和接口。驱动的开发，就简化为对内核所规定的数据结构的填充和实现。 硬件拓扑结构示例 硬件拓扑中可以看到Bus、Class、Device三个部分 http://www.wowotech.net/device_model/13.html Bus Linux认为总线是CPU和设备之间通信的通道，在设备模型中，所有的设备都需要连接到总线上，之后才能和cpu通信。 但是对于芯片内一些外设而言是直接和cpu通信的，比如cpu可以直接寻址到uart控制器，因此抽象了一个platform bus将这些设备挂上去 Class 面向对象程序设计思想中的类，将具有相似功能或属性的设备抽象，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数。因而从属于相同Class的设备的驱动程序，就不再需要重复定义这些公共资源，直接从Class中继承即可。 Device 抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。 Device_driver Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。而Linux内核中的驱动开发，基本都围绕该抽象进行（实现所规定的接口函数）。 1.1. 核心思想 bus把device和driver联系起来，device解决“有什么东西可用”的问题，driver解决“怎么用这个东西”的问题，这样驱动开发就变成了填空题 Device和Device_driver匹配上之后，就会执行Device_driver中的初始化函数（probe），设备被初始化，之后就可供consumer使用 对于热插拔设备而言，Device_driver一直运行在内核中等待设备。没有设备插入的时候，没有Device结构体信息，因此Driver也就不会执行，当设备插入，内核会创建Device结构体，此时就会触发Driver执行 通过Bus--->Device的树状结构解决设备直接的依赖，要启动某个设备，会检查它依赖的总线和设备，先启动依赖项在启动设备 在设备驱动中明确设备的依赖关系，之后内核能自动处理启动顺序 通过Class抽象共性 2. 相关数据结构 struct device是内核中描述设备的结构体，一般来说会针对具体的设备再新建一个结构体，而struct device作为其一成员变量。 /** * struct device - The basic device structure * @parent: The device's \"parent\" device, the device to which it is attached. * In most cases, a parent device is some sort of bus or host * controller. If parent is NULL, the device, is a top-level device, * which is not usually what you want. * @p: Holds the private data of the driver core portions of the device. * See the comment of the struct device_private for detail. * @kobj: A top-level, abstract class from which other classes are derived. * @init_name: Initial name of the device. * @type: The type of device. * This identifies the device type and carries type-specific * information. * @mutex: Mutex to synchronize calls to its driver. * @bus: Type of bus device is on. * @driver: Which driver has allocated this * @platform_data: Platform data specific to the device. * Example: For devices on custom boards, as typical of embedded * and SOC based hardware, Linux often uses platform_data to point * to board-specific structures describing devices and how they * are wired. That can include what ports are available, chip * variants, which GPIO pins act in what additional roles, and so * on. This shrinks the \"Board Support Packages\" (BSPs) and * minimizes board-specific #ifdefs in drivers. * @driver_data: Private pointer for driver specific info. * @links: Links to suppliers and consumers of this device. * @power: For device power management. * See Documentation/driver-api/pm/devices.rst for details. * @pm_domain: Provide callbacks that are executed during system suspend, * hibernation, system resume and during runtime PM transitions * along with subsystem-level and driver-level callbacks. * @pins: For device pin management. * See Documentation/driver-api/pinctl.rst for details. * @msi_list: Hosts MSI descriptors * @msi_domain: The generic MSI domain this device is using. * @numa_node: NUMA node this device is close to. * @dma_ops: DMA mapping operations for this device. * @dma_mask: Dma mask (if dma'ble device). * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all * hardware supports 64-bit addresses for consistent allocations * such descriptors. * @bus_dma_mask: Mask of an upstream bridge or bus which imposes a smaller DMA * limit than the device itself supports. * @dma_pfn_offset: offset of DMA memory range relatively of RAM * @dma_parms: A low level driver may set these to teach IOMMU code about * segment limitations. * @dma_pools: Dma pools (if dma'ble device). * @dma_mem: Internal for coherent mem override. * @cma_area: Contiguous memory area for dma allocations * @archdata: For arch-specific additions. * @of_node: Associated device tree node. * @fwnode: Associated device node supplied by platform firmware. * @devt: For creating the sysfs \"dev\". * @id: device instance * @devres_lock: Spinlock to protect the resource of the device. * @devres_head: The resources list of the device. * @knode_class: The node used to add the device to the class list. * @class: The class of the device. * @groups: Optional attribute groups. * @release: Callback to free the device after all references have * gone away. This should be set by the allocator of the * device (i.e. the bus driver that discovered the device). * @iommu_group: IOMMU group the device belongs to. * @iommu_fwspec: IOMMU-specific properties supplied by firmware. * * @offline_disabled: If set, the device is permanently online. * @offline: Set after successful invocation of bus type's .offline(). * @of_node_reused: Set if the device-tree node is shared with an ancestor * device. * * At the lowest level, every device in a Linux system is represented by an * instance of struct device. The device structure contains the information * that the device model core needs to model the system. Most subsystems, * however, track additional information about the devices they host. As a * result, it is rare for devices to be represented by bare device structures; * instead, that structure, like kobject structures, is usually embedded within * a higher-level representation of the device. */ struct device { struct device *parent; //父设备，一般是bus或者controller struct device_private *p; //设备的私有信息 struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; //电源管理相关 struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; struct device_driver是内核中描述设备驱动的结构体，include/linux/device.h /** * struct device_driver - The basic device driver structure * @name: Name of the device driver. * @bus: The bus which the device of this driver belongs to. * @owner: The module owner. * @mod_name: Used for built-in modules. * @suppress_bind_attrs: Disables bind/unbind via sysfs. * @probe_type: Type of the probe (synchronous or asynchronous) to use. * @of_match_table: The open firmware table. * @acpi_match_table: The ACPI match table. * @probe: Called to query the existence of a specific device, * whether this driver can work with it, and bind the driver * to a specific device. * @remove: Called when the device is removed from the system to * unbind a device from this driver. * @shutdown: Called at shut-down time to quiesce the device. * @suspend: Called to put the device to sleep mode. Usually to a * low power state. * @resume: Called to bring a device from sleep mode. * @groups: Default attributes that get created by the driver core * automatically. * @pm: Power management operations of the device which matched * this driver. * @coredump: Called when sysfs entry is written to. The device driver * is expected to call the dev_coredump API resulting in a * uevent. * @p: Driver core's private data, no one other than the driver * core can touch this. * * The device driver-model tracks all of the drivers known to the system. * The main reason for this tracking is to enable the driver core to match * up drivers with new devices. Once drivers are known objects within the * system, however, a number of other things become possible. Device drivers * can export information and configuration variables that are independent * of any specific device. */ struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); //检测到设备执行 int (*remove) (struct device *dev); //设备移除时执行 void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; 3. 驱动开发基本步骤 在设备驱动模型框架下，设备驱动开发主要分两步 分配一个struct device类型的变量，填充必要的信息后，把它注册到内核中。 分配一个struct device_driver类型的变量，填充必要的信息后，把它注册到内核中。 这两步完成后，内核会在合适的时机，调用struct device_driver变量中的probe、remove、suspend、resume等回调函数，从而触发或者终结设备驱动的执行。而所有的驱动程序逻辑，都会由这些回调函数实现，此时，驱动开发者眼中便不再有“设备模型”，转而只关心驱动本身的实现。 一般情况下，struct device和struct device_driver都会被再包装一次或几次，针对具体设备进行相应封装处理。 内核提供一些对struct device操作的api，主要在drivers/base/core.c 如device_initialize初始化，device_register注册到内核，device_create分配存储空间+初始化+注册到内核。 device和device_driver必须具备相同的名称，内核才能完成匹配操作，进而调用device_driver中的相应接口。这里的同名，作用范围是同一个bus下的所有device和device_driver ???????? dts中的compatible属性和这里提到的相同名字是什么关系 device和device_driver需要挂在同一个bus下 driver开发者可以在struct device变量中，保存描述设备特征的信息，如寻址空间、依赖的GPIOs等，因为device指针会在执行probe等接口时传入，这时driver就可以根据这些信息，执行相应的逻辑操作了。 4. probe 设备的probe由bus完成；每个bus都有一个drivers_autoprobe变量，通过这个变量来控制bus的行为（是否需要自动probe） 将struct device类型的变量注册到内核中时自动触发（device_register，device_add，device_create_vargs，device_create） 将struct device_driver类型的变量注册到内核中时自动触发（driver_register） 手动查找同一bus下的所有device_driver，如果有和指定device同名的driver，执行probe操作（device_attach） 手动查找同一bus下的所有device，如果有和指定driver同名的device，执行probe操作（driver_attach） 自行调用driver的probe接口，并在该接口中将该driver绑定到某个device结构中，即设置dev->driver（device_bind_driver） 5. platform驱动模型 6. i2c驱动模型 https://www.eet-china.com/mp/a34101.html 对于i2c驱动模型而言 Bus是一个全局变量struct bus_type i2c_bus_type Driver是struct i2c_driver类型的变量 Device是struct i2c_client，但一般会对i2c_client在封装一层 比如struct ov5645的成员变量中有struct i2c_client 怎么理解https://kernel.meizu.com/device-tree.html的3.2.2 mt_i2c_driver 因为第1级子节点会被注册成platform device，例如i2c/spi控制器，那么对应也需要注册platform driver。以i2c控制器驱动为例： 控制器首先会创建对应platform driver，把adapter注册成i2c device； 怎么理解控制器创建 这里的 i2c device是什么数据类型？这里不应该是把adapter注册成 在adapter的probe过程中，会调用of_i2c_register_devices()函数遍历控制器下挂的i2c设备的DTS节点，并将其注册成i2c_client； 6.1. 数据结构 6.1.1. bus kernel通过struct bus_type结构体来维护bus include/linux/device.h /** * struct bus_type - The bus type of the device * * @name: The name of the bus. * @dev_name: Used for subsystems to enumerate devices like (\"foo%u\", dev->id). * @dev_root: Default device to use as the parent. * @bus_groups: Default attributes of the bus. * @dev_groups: Default attributes of the devices on the bus. * @drv_groups: Default attributes of the device drivers on the bus. * @match: Called, perhaps multiple times, whenever a new device or driver * is added for this bus. It should return a positive value if the * given device can be handled by the given driver and zero * otherwise. It may also return error code if determining that * the driver supports the device is not possible. In case of * -EPROBE_DEFER it will queue the device for deferred probing. * @uevent: Called when a device is added, removed, or a few other things * that generate uevents to add the environment variables. * @probe: Called when a new device or driver add to this bus, and callback * the specific driver's probe to initial the matched device. * @remove: Called when a device removed from this bus. * @shutdown: Called at shut-down time to quiesce the device. * * @online: Called to put the device back online (after offlining it). * @offline: Called to put the device offline for hot-removal. May fail. * * @suspend: Called when a device on this bus wants to go to sleep mode. * @resume: Called to bring a device on this bus out of sleep mode. * @num_vf: Called to find out how many virtual functions a device on this * bus supports. * @dma_configure: Called to setup DMA configuration on a device on * this bus. * @pm: Power management operations of this bus, callback the specific * device driver's pm-ops. * @iommu_ops: IOMMU specific operations for this bus, used to attach IOMMU * driver implementations to a bus and allow the driver to do * bus-specific setup * @p: The private data of the driver core, only the driver core can * touch this. * @lock_key: Lock class key for use by the lock validator * @need_parent_lock: When probing or removing a device on this bus, the * device core should lock the device's parent. * * A bus is a channel between the processor and one or more devices. For the * purposes of the device model, all devices are connected via a bus, even if * it is an internal, virtual, \"platform\" bus. Buses can plug into each other. * A USB controller is usually a PCI device, for example. The device model * represents the actual connections between buses and the devices they control. * A bus is represented by the bus_type structure. It contains the name, the * default attributes, the bus' methods, PM operations, and the driver core's * private data. */ struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; i2c_bus_type struct bus_type i2c_bus_type = { .name = \"i2c\", .match = i2c_device_match, //判断传入的 device和driver是否匹配 .probe = i2c_device_probe, .remove = i2c_device_remove, .shutdown = i2c_device_shutdown, }; EXPORT_SYMBOL_GPL(i2c_bus_type); probe，注册一个driver（struct i2c_driver）或者一个device（struct i2c_client）的时候，先通过match匹配，如果成功就调用driver中的probe函数 remove，当卸载driver或者device时，会调用remove来释放相应资源 在drivers/i2c/i2c-core-base.c的i2c_init()中有retval = bus_register(&i2c_bus_type);，向内核注册i2c总线 kernel总线维护驱动链表、设备链表两个链表，i2c_driver中的struct list_head clients;和i2c_client中的struct list_head detected;是链表项（链表注意container_of宏） 6.1.2. driver /** * struct i2c_driver - represent an I2C device driver * @class: What kind of i2c device we instantiate (for detect) * @probe: Callback for device binding - soon to be deprecated * @probe_new: New callback for device binding * @remove: Callback for device unbinding * @shutdown: Callback for device shutdown * @alert: Alert callback, for example for the SMBus alert protocol * @command: Callback for bus-wide signaling (optional) * @driver: Device driver model driver * @id_table: List of I2C devices supported by this driver * @detect: Callback for device detection * @address_list: The I2C addresses to probe (for detect) * @clients: List of detected clients we created (for i2c-core use only) * @disable_i2c_core_irq_mapping: Tell the i2c-core to not do irq-mapping * * The driver.owner field should be set to the module owner of this driver. * The driver.name field should be set to the name of this driver. * * For automatic device detection, both @detect and @address_list must * be defined. @class should also be set, otherwise only devices forced * with module parameters will be created. The detect function must * fill at least the name field of the i2c_board_info structure it is * handed upon successful detection, and possibly also the flags field. * * If @detect is missing, the driver will still work fine for enumerated * devices. Detected devices simply won't be supported. This is expected * for the many I2C/SMBus devices which can't be detected reliably, and * the ones which can always be enumerated in practice. * * The i2c_client structure which is handed to the @detect callback is * not a real i2c_client. It is initialized just enough so that you can * call i2c_smbus_read_byte_data and friends on it. Don't do anything * else with it. In particular, calling dev_dbg and friends on it is * not allowed. */ struct i2c_driver { unsigned int class; /* Standard driver model interfaces */ int (*probe)(struct i2c_client *, const struct i2c_device_id *); int (*remove)(struct i2c_client *); /* New driver model interface to aid the seamless removal of the * current probe()'s, more commonly unused than used second parameter. */ int (*probe_new)(struct i2c_client *); /* driver model interfaces that don't relate to enumeration */ void (*shutdown)(struct i2c_client *); /* Alert callback, for example for the SMBus alert protocol. * The format and meaning of the data value depends on the protocol. * For the SMBus alert protocol, there is a single bit of data passed * as the alert response's low bit (\"event flag\"). * For the SMBus Host Notify protocol, the data corresponds to the * 16-bit payload data reported by the slave device acting as master. */ void (*alert)(struct i2c_client *, enum i2c_alert_protocol protocol, unsigned int data); /* a ioctl like command that can be used to perform specific functions * with the device. */ int (*command)(struct i2c_client *client, unsigned int cmd, void *arg); struct device_driver driver; const struct i2c_device_id *id_table; /* Device detection callback for automatic device creation */ int (*detect)(struct i2c_client *, struct i2c_board_info *); const unsigned short *address_list; struct list_head clients; bool disable_i2c_core_irq_mapping; }; 6.1.3. device device_node 是从设备树中解析出来的，需要转换为device（如platfrom_device，i2c_client等） /** * struct i2c_client - represent an I2C slave device * @flags: I2C_CLIENT_TEN indicates the device uses a ten bit chip address; * I2C_CLIENT_PEC indicates it uses SMBus Packet Error Checking * @addr: Address used on the I2C bus connected to the parent adapter. * @name: Indicates the type of the device, usually a chip name that's * generic enough to hide second-sourcing and compatible revisions. * @adapter: manages the bus segment hosting this I2C device * @dev: Driver model device node for the slave. * @irq: indicates the IRQ generated by this device (if any) * @detected: member of an i2c_driver.clients list or i2c-core's * userspace_devices list * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter * calls it to pass on slave events to the slave driver. * * An i2c_client identifies a single device (i.e. chip) connected to an * i2c bus. The behaviour exposed to Linux is defined by the driver * managing the device. */ struct i2c_client { unsigned short flags; /* div., see below */ unsigned short addr; /* chip address - NOTE: 7bit */ /* addresses are stored in the */ /* _LOWER_ 7 bits */ char name[I2C_NAME_SIZE]; struct i2c_adapter *adapter; /* the adapter we sit on */ struct device dev; /* the device structure */ int init_irq; /* irq set at initialization */ int irq; /* irq issued by device */ struct list_head detected; #if IS_ENABLED(CONFIG_I2C_SLAVE) i2c_slave_cb_t slave_cb; /* callback for slave mode */ #endif }; 6.2. 注册流程 向内核注册完bus之后，只是有了一个总线，总线上没有任何设备，需要再向上面注册i2c_adapter和其他的i2c_client， 其中i2c_adapter是主设备，i2c_client是从设备 这个不准确？这里注册的 bustype不知道是什么东西 设备树中关于i2c节点的描述，内核会为其创建一个platform device在platform bus中，会根据compatible匹配到相应的驱动drivers/i2c/busses/i2c-riic.c 在i2c的platform驱动（总线驱动？）的probe函数中，会创建i2c_adapter设备，并通过ret = i2c_add_adapter(adap);添加到i2c总线中。设备树中写了3个i2c节点，所以这里会执行3遍 为什么这里不需要指定是把当前的i2c_adapter添加到哪个i2c总线中？还是说对于linux来说一个i2c_adapter就是一个总线？那i2c_add_adapter()，是把adapter添加到了哪里？ 如果，每一个i2c_adapter就代表一条i2c总线，linux中用i2c_adapter来区分不同i2c bus，所以上面的i2c_add_adapter()是向i2c子系统进行注册？ 那为什么需要通过postcore_initcall(i2c_init);这里面进行bus_register，很明显这里只执行了一次，所以对于kernel来说只是注册了一条bus？ i2c_adapter对应物理设备（芯片内的i2c控制器），结构体中有struct list_head userspace_clients;这个链表是所有接在这个adapter下的设备，即这个i2c总线上的所有i2c_client static int i2c_register_adapter(struct i2c_adapter *adap) res = device_register(&adap->dev); of_i2c_register_devices(adap); 现在两个文档对于 i2c_client的注册 有两个说法 https://blog.csdn.net/snowwupl/article/details/9014977 说i2c_scan_static_board_info()是重点 https://www.eet-china.com/mp/a34101.html 说是of_i2c_register_devices(adap); 6.2.1. bus注册 https://zhuanlan.zhihu.com/p/363569568 https://sites.google.com/site/myembededlife/Home/s3c2440/i2c-and-core_initcall https://blog.csdn.net/u010961173/article/details/90770615 drivers/i2c/i2c-core-base.c是 i2c 子系统的核心，在这里向内核注册bus postcore_initcall(i2c_init);声明initcall static int __init i2c_init(void) retval = bus_register(&i2c_bus_type); 这个是最早执行的，在start_kernel()中根据initcall相关调用顺序执行的， 可能甚至是跟platform总线是一块注册的？ 6.2.2. i2c_driver向内核注册 module_i2c_driver(ov5645_i2c_driver); return i2c_add_driver(&(ov5645_i2c_driver) ); i2c_register_driver(THIS_MODULE, driver) res = driver_register(&driver->driver); ret = bus_add_driver(drv); error = driver_attach(drv); return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach); error = fn(dev, data); fn是函数指针，值为传入的形参__driver_attach ret = driver_match_device(drv, dev); return drv->bus->match ? drv->bus->match(dev, drv) : 1; 调用的是i2c_bus_type->match,即i2c_device_match() driver_probe_device(drv, dev); ret = really_probe(dev, drv); ret = drv->probe(dev); error = driver_create_file(drv, &driver_attr_uevent); drivers/media/i2c/ov5645.c中有 static struct i2c_driver ov5645_i2c_driver = { .driver = { .of_match_table = of_match_ptr(ov5645_of_match), .name = \"ov5645\", }, .probe = ov5645_probe, .remove = ov5645_remove, .id_table = ov5645_id, }; module_i2c_driver(ov5645_i2c_driver); module_i2c_driver宏是include/linux/i2c.h提供的工具，展开之后如下 static int __init ov5645_i2c_driver_init(void) { return i2c_add_driver(&(ov5645_i2c_driver) ); } module_init(ov5645_i2c_driver_init); static void __exit ov5645_i2c_driver_exit(void) { i2c_del_driver(&(ov5645_i2c_driver) ); } module_exit(ov5645_i2c_driver_exit); insmod和rmmod会用到module_init和module_exit i2c_add_driver也是宏，最终调用的是int i2c_register_driver(struct module *, struct i2c_driver *); driver->of_match_table->compatible和i2c_client->name --> 6.2.3. 构建i2c_client 在有设备树的情况下，i2c_client的生成是要在控制器驱动adapter注册情况下从设备树中枚举出来的。 i2c控制器有很多种，不同的厂家都会设计自己特有的i2c控制器，但是不论哪一个控制器，最终都会调用 i2c_register_adapter()注册控制器驱动。 drivers/i2c/busses/i2c-riic.c 调用栈 static int riic_i2c_probe(struct platform_device *pdev) ret = i2c_add_adapter(adap); return i2c_register_adapter(adapter); of_i2c_register_devices(adap); 遍历子节点client = of_i2c_register_device(adap, node); ret = of_i2c_get_board_info(&adap->dev, node, &info); if (of_modalias_node(node, info->type, sizeof(info->type)) 通过compatibles获取name ret = of_property_read_u32(node, \"reg\", &addr);获取reg，即i2c地址 client = i2c_new_device(adap, &info); 申请内存 status = device_register(&client->dev); 向内核中注册device return device_add(dev); error = bus_add_device(dev); bus_probe_device(dev); device_initial_probe(dev); __device_attach(dev, true); ret = bus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver); error = fn(drv, data); fn是传进的函数指针，__device_attach_driver return driver_probe_device(drv, dev); ret = really_probe(dev, drv); ret = drv->probe(dev); 在i2c_register_adapter()中会先遍历i2c的设备树节点，这里就会得到i2c控制器节点中的各种设备子节点，创建create pre-declared device nodes 所以在i2c adapter注册的时候就已经创建好device了，在i2c驱动模型中， static int i2c_register_adapter(struct i2c_adapter *adap) { int res = -EINVAL; /* Can't register until after driver model init */ if (WARN_ON(!is_registered)) { res = -EAGAIN; goto out_list; } /* Sanity checks */ if (WARN(!adap->name[0], \"i2c adapter has no name\")) goto out_list; if (!adap->algo) { pr_err(\"adapter '%s': no algo supplied!\\n\", adap->name); goto out_list; } if (!adap->lock_ops) adap->lock_ops = &i2c_adapter_lock_ops; rt_mutex_init(&adap->bus_lock); rt_mutex_init(&adap->mux_lock); mutex_init(&adap->userspace_clients_lock); INIT_LIST_HEAD(&adap->userspace_clients); /* Set default timeout to 1 second if not already set */ if (adap->timeout == 0) adap->timeout = HZ; /* register soft irqs for Host Notify */ res = i2c_setup_host_notify_irq_domain(adap); if (res) { pr_err(\"adapter '%s': can't create Host Notify IRQs (%d)\\n\", adap->name, res); goto out_list; } dev_set_name(&adap->dev, \"i2c-%d\", adap->nr); adap->dev.bus = &i2c_bus_type; adap->dev.type = &i2c_adapter_type; res = device_register(&adap->dev); if (res) { pr_err(\"adapter '%s': can't register device (%d)\\n\", adap->name, res); goto out_list; } res = of_i2c_setup_smbus_alert(adap); if (res) goto out_reg; dev_dbg(&adap->dev, \"adapter [%s] registered\\n\", adap->name); pm_runtime_no_callbacks(&adap->dev); pm_suspend_ignore_children(&adap->dev, true); pm_runtime_enable(&adap->dev); #ifdef CONFIG_I2C_COMPAT res = class_compat_create_link(i2c_adapter_compat_class, &adap->dev, adap->dev.parent); if (res) dev_warn(&adap->dev, \"Failed to create compatibility class link\\n\"); #endif i2c_init_recovery(adap); /* create pre-declared device nodes */ of_i2c_register_devices(adap); //这里遍历i2c所有子节点，并分别为`struct i2c_client*`申请内存空间，填充相关信息到i2c_client i2c_acpi_install_space_handler(adap); i2c_acpi_register_devices(adap); if (adap->nr dev_released); device_unregister(&adap->dev); wait_for_completion(&adap->dev_released); out_list: mutex_lock(&core_lock); idr_remove(&i2c_adapter_idr, adap->nr); mutex_unlock(&core_lock); return res; } "},"Linux/Linux-reset-framework.html":{"url":"Linux/Linux-reset-framework.html","title":"Linux-reset-framework","keywords":"","body":"Linux reset framework 1. 问题 2. linux reset framework 2.1. 对于provider 2.2. 对于consumer 2.3. 附 3. 分析 4. Call trace 4.1. devm_reset_control_get(dev, id) 4.2. devm_reset_control_get_exclusive() 4.3. __devm_reset_control_get(dev, id, index, shared, optional) 4.4. __reset_control_get 4.5. __of_reset_control_get(pdev->dev.of_node, NULL, 0, false, false) 4.5.1. 关于of_parse_phandle_with_args() 4.6. __reset_control_get_internal(rcdev, index, shared) 5. 结论 6. 参考 1. 问题 gpt3和gpt6同时打开，内核启动阶段会报错failed to get cpg reset [root@okg2l ~ ]# dmesg |grep gpt [ 0.090055] gpt-rzg2l 10048300.gpt: RZ/G2L GPT Driver probed [ 0.090361] rzg2l_gpt_probe+0x90/0x378 [ 0.090409] rzg2l_gpt_driver_init+0x18/0x20 [ 0.090453] gpt-rzg2l 10048600.gpt: failed to get cpg reset [ 0.090506] gpt-rzg2l: probe of 10048600.gpt failed with error -16 错误-16 #define EBUSY 16 /* Device or resource busy */ 在drivers/pwm/gpt-rzg2l.c的rzg2l_gpt_probe函数中可以看到关于cpg的配置信息 在probe过程中，需要申请rstc，即复位控制器资源，但是，只有第一次gpt3能成功获取，第二次gpt6就不能再获取这个资源 2. linux reset framework soc内部会有很多独立的模块，比如串口，定时器，spi等，对于这些外设，使用的时候可能需要用到复位信号，软件通过操作某些寄存器（一般一个外设对应1bit）即可完成对外设的复位。 kernel内抽象了一个reset framework，给reset的provider提供了统一的reset资源的管理手段，为reset的consumer提供便捷、统一的复位控制API。 2.1. 对于provider 接口在include/linux/reset-controller.h 主要是构建struct reset_controller_dev结构体 /** * struct reset_controller_dev - reset controller entity that might * provide multiple reset controls * @ops: a pointer to device specific struct reset_control_ops * @owner: kernel module of the reset controller driver * @list: internal list of reset controller devices * @reset_control_head: head of internal list of requested reset controls * @dev: corresponding driver model device struct * @of_node: corresponding device tree node as phandle target * @of_reset_n_cells: number of cells in reset line specifiers * @of_xlate: translation function to translate from specifier as found in the * device tree to id as given to the reset control ops * @nr_resets: number of reset controls in this reset controller device */ struct reset_controller_dev { const struct reset_control_ops *ops; struct module *owner; struct list_head list; struct list_head reset_control_head; struct device *dev; struct device_node *of_node; int of_reset_n_cells; int (*of_xlate)(struct reset_controller_dev *rcdev, const struct of_phandle_args *reset_spec); unsigned int nr_resets; }; 然后调用相应接口函数向内核注册reset设备 int reset_controller_register(struct reset_controller_dev *rcdev); void reset_controller_unregister(struct reset_controller_dev *rcdev); struct device; int devm_reset_controller_register(struct device *dev, struct reset_controller_dev *rcdev); void reset_controller_add_lookup(struct reset_control_lookup *lookup, unsigned int num_entries); 2.2. 对于consumer 接口在include/linux/reset.h consumer设备在自己的dts node中使用resets、reset-names等关键字声明所需的reset资源。resets属性的具体格式由provider决定 device { resets = ; reset-names = \"reset\"; }; consumer driver在需要的时候，先获取设备树中设置的reset资源rstc static inline struct reset_control *devm_reset_control_get(struct device *dev, const char *id) static inline struct reset_control *devm_reset_control_get_shared(struct device *dev, const char *id) static inline struct reset_control *devm_reset_control_get_optional(struct device *dev, const char *id) 获取到rstc之后即可调用API复位设备 int reset_control_reset(struct reset_control *rstc); int reset_control_assert(struct reset_control *rstc); int reset_control_deassert(struct reset_control *rstc); int reset_control_status(struct reset_control *rstc); 2.3. 附 在linux reset framework中，每个reset_controller_dev都维护着一个链表，这个链表里存放的是系统运行过程中被申请的reset资源 每一个外设对应的复位控制相关寄存器都是一个reset资源 reset资源体现为struct reset_control *rstc kernel把芯片上所有的reset资源统一交由reset_controller_dev管理 include/dt-bindings/clock/r9a07g044l-cpg.h定义了rzg2l芯片的所有reset资源 例如芯片手册 7.2.4.121 Reset Control Register GPT (CPG_RST_GPT) 对于gpt来说，gpt01234567共用一个复位信号，所以一共有1个reset资源，在r9a07g044l-cpg.h中有相应定义 #define R9A07G044L_CLK_GPT 6 芯片手册 7.2.4.138 Reset Control Register SCIF (CPG_RST_SCIF)是串口scif的复位相关寄存器 对于scif来说，scif01234，每一路串口都有一个独立的复位信号，所以一共有5个reset资源，在r9a07g044l-cpg.h中有相应定义 #define R9A07G044L_CLK_SCIF0 13 #define R9A07G044L_CLK_SCIF1 14 #define R9A07G044L_CLK_SCIF2 15 #define R9A07G044L_CLK_SCIF3 16 #define R9A07G044L_CLK_SCIF4 17 3. 分析 static int rzg2l_gpt_probe(struct platform_device *pdev) { ... rzg2l_gpt->rstc = devm_reset_control_get(&pdev->dev, NULL); if (IS_ERR(rzg2l_gpt->rstc)) { dev_err(δpdev->dev, \"failed to get cpg reset\\n\"); // return PTR_ERR(rzg2l_gpt->rstc); } ... } 对rstc异常情况不return，继续执行，第一次（gpt-rzg2l 10048300.gpt）在devm_reset_control_get()可以正常执行，第二次（gpt-rzg2l 10048600.gpt）会报错 [ 0.092427] gpt-rzg2l 10048300.gpt: GPT not use POEG [ 0.092642] gpt-rzg2l 10048300.gpt: RZ/G2L GPT Driver probed [ 0.092851] gpt-rzg2l 10048600.gpt: GPT not use POEG [ 0.092859] ------------[ cut here ]------------ [ 0.092903] WARNING: CPU: 1 PID: 1 at drivers/reset/core.c:419 __reset_control_get_internal+0xdc/0x128 [ 0.092906] Modules linked in: [ 0.092916] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.19.165-cip41-arm64-renesas #2 [ 0.092919] Hardware name: Forlinx OKG2L Evaluation board (DT) [ 0.092923] pstate: 40c00005 (nZcv daif +PAN +UAO) [ 0.092928] pc : __reset_control_get_internal+0xdc/0x128 [ 0.092933] lr : __reset_control_get_internal+0xdc/0x128 [ 0.092935] sp : ffff000008013a50 [ 0.092937] x29: ffff000008013a50 x28: 0000000000000000 [ 0.092942] x27: 0000000000000000 x26: ffff000008e204e0 [ 0.092946] x25: ffff000008e7d060 x24: 0000000000000000 [ 0.092950] x23: 0000000000000000 x22: ffff80007d72aa80 [ 0.092954] x21: 0000000000000006 x20: ffff80007d72aaa0 [ 0.092958] x19: ffff80007ce9b200 x18: ffff000008ec1000 [ 0.092962] x17: 0000000000000fff x16: 0000000000007fff [ 0.092966] x15: 00000000fffffff0 x14: ffff000008f60c72 [ 0.092969] x13: 0000000000000000 x12: ffff000008f60000 [ 0.092973] x11: ffff000008ec1000 x10: ffff000008f602c8 [ 0.092977] x9 : 0000000000000000 x8 : 0000000000000004 [ 0.092981] x7 : ffff000008f60000 x6 : 000000000000008c [ 0.092985] x5 : 0000000000000000 x4 : 0000000000000000 [ 0.092988] x3 : ffffffffffffffff x2 : 1be4e7ac3d036e00 [ 0.092992] x1 : 0000000000000000 x0 : 0000000000000024 [ 0.092997] Call trace: [ 0.093003] __reset_control_get_internal+0xdc/0x128 [ 0.093008] __of_reset_control_get+0x13c/0x1b8 [ 0.093011] __reset_control_get+0x30/0x1a8 [ 0.093016] __devm_reset_control_get+0x64/0xd8 [ 0.093024] rzg2l_gpt_probe+0x130/0x4a8 [ 0.093032] platform_drv_probe+0x50/0xa0 [ 0.093036] really_probe+0x1dc/0x298 [ 0.093040] driver_probe_device+0x54/0xe8 [ 0.093044] __driver_attach+0xe0/0xe8 [ 0.093048] bus_for_each_dev+0x70/0xc0 [ 0.093051] driver_attach+0x20/0x28 [ 0.093055] bus_add_driver+0x1dc/0x208 [ 0.093059] driver_register+0x60/0x110 [ 0.093063] __platform_driver_register+0x44/0x50 [ 0.093071] rzg2l_gpt_driver_init+0x18/0x20 [ 0.093078] do_one_initcall+0x74/0x178 [ 0.093084] kernel_init_freeable+0x18c/0x224 [ 0.093092] kernel_init+0x10/0x104 [ 0.093096] ret_from_fork+0x10/0x18 [ 0.093103] ---[ end trace 7dc9776788e7d665 ]--- [ 0.093110] gpt-rzg2l 10048600.gpt: failed to get cpg reset [ 0.093128] ------------[ cut here ]------------ [ 0.093153] WARNING: CPU: 1 PID: 1 at drivers/reset/core.c:360 reset_control_deassert+0x128/0x138 [ 0.093155] Modules linked in: [ 0.093161] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G W 4.19.165-cip41-arm64-renesas #2 [ 0.093163] Hardware name: Forlinx OKG2L Evaluation board (DT) [ 0.093166] pstate: 40c00005 (nZcv daif +PAN +UAO) [ 0.093171] pc : reset_control_deassert+0x128/0x138 [ 0.093175] lr : reset_control_deassert+0x128/0x138 [ 0.093177] sp : ffff000008013b90 [ 0.093179] x29: ffff000008013b90 x28: 0000000000000000 [ 0.093183] x27: 0000000000000000 x26: ffff000008e204e0 [ 0.093187] x25: ffff000008e7d060 x24: ffff000008edeaf0 [ 0.093191] x23: ffff80007d687400 x22: ffff000008eaa688 [ 0.093195] x21: ffff80007cd6fa80 x20: ffff80007d687410 [ 0.093199] x19: fffffffffffffff0 x18: ffff000008ec1000 [ 0.093203] x17: 0000000000000fff x16: 0000000000007fff [ 0.093207] x15: 00000000fffffff0 x14: ffff000008f60c72 [ 0.093211] x13: 0000000000000000 x12: ffff000008f60000 [ 0.093215] x11: ffff000008ec1000 x10: ffff000008f602c8 [ 0.093219] x9 : 0000000000000000 x8 : 0000000000000004 [ 0.093222] x7 : ffff000008f60000 x6 : 00000000000000ba [ 0.093226] x5 : 0000000000000000 x4 : 0000000000000000 [ 0.093230] x3 : ffffffffffffffff x2 : 1be4e7ac3d036e00 [ 0.093233] x1 : 0000000000000000 x0 : 0000000000000024 [ 0.093237] Call trace: [ 0.093241] reset_control_deassert+0x128/0x138 [ 0.093246] rzg2l_gpt_probe+0x140/0x4a8 [ 0.093251] platform_drv_probe+0x50/0xa0 [ 0.093254] really_probe+0x1dc/0x298 [ 0.093258] driver_probe_device+0x54/0xe8 [ 0.093262] __driver_attach+0xe0/0xe8 [ 0.093265] bus_for_each_dev+0x70/0xc0 [ 0.093269] driver_attach+0x20/0x28 [ 0.093273] bus_add_driver+0x1dc/0x208 [ 0.093276] driver_register+0x60/0x110 [ 0.093280] __platform_driver_register+0x44/0x50 [ 0.093285] rzg2l_gpt_driver_init+0x18/0x20 [ 0.093289] do_one_initcall+0x74/0x178 [ 0.093292] kernel_init_freeable+0x18c/0x224 [ 0.093297] kernel_init+0x10/0x104 [ 0.093301] ret_from_fork+0x10/0x18 [ 0.093303] ---[ end trace 7dc9776788e7d666 ]--- [ 0.093506] gpt-rzg2l 10048600.gpt: RZ/G2L GPT Driver probed 根据设备树中的compatible属性，两个节点会调用两次static int rzg2l_gpt_probe(struct platform_device *pdev)函数 报错信息来自rzg2l_gpt->rstc = devm_reset_control_get(&pdev->dev, NULL);，设备树里面有gpt3，gpt6两个节点都enabled，第一次执行不报错，第二次报错 4. Call trace rzg2l_gpt->rstc = devm_reset_control_get(&pdev->dev, NULL); return devm_reset_control_get_exclusive(dev, id); return __devm_reset_control_get(dev, id, 0, false, false); rstc = __reset_control_get(&pdev->dev, NULL, 0, false, false); return __of_reset_control_get(pdev->dev.of_node, NULL, 0, false, false); rstc = __reset_control_get_internal(rcdev, rstc_id, shared); 4.1. devm_reset_control_get(dev, id) dev是platform device，这里即gpt设备 id NULL static inline struct reset_control *devm_reset_control_get( struct device *dev, const char *id) { return devm_reset_control_get_exclusive(dev, id); } 4.2. devm_reset_control_get_exclusive() static inline struct reset_control * __must_check devm_reset_control_get_exclusive(struct device *dev, const char *id) { return __devm_reset_control_get(dev, id, 0, false, false); } 4.3. __devm_reset_control_get(dev, id, index, shared, optional) indexindex是指第0个 sharedreset资源是否共享 optional是否可选，是否为非必选 reset控制器是设备，所有的reset资源都视为设备，这里是申请reset设备资源 struct reset_control *__devm_reset_control_get(struct device *dev, const char *id, int index, bool shared, bool optional) { struct reset_control **ptr, *rstc; ptr = devres_alloc(devm_reset_control_release, sizeof(*ptr), GFP_KERNEL); if (!ptr) return ERR_PTR(-ENOMEM); rstc = __reset_control_get(dev, id, index, shared, optional); //获取rstc if (!IS_ERR(rstc)) { *ptr = rstc; devres_add(dev, ptr); } else { devres_free(ptr); } return rstc; } EXPORT_SYMBOL_GPL(__devm_reset_control_get); 4.4. __reset_control_get struct reset_control *__reset_control_get(struct device *dev, const char *id, int index, bool shared, bool optional) { if (dev->of_node) return __of_reset_control_get(dev->of_node, id, index, shared, //解析设备树，获取rstc optional); return __reset_control_get_from_lookup(dev, id, shared, optional); } EXPORT_SYMBOL_GPL(__reset_control_get); 4.5. __of_reset_control_get(pdev->dev.of_node, NULL, 0, false, false) node传入的设备树节点，gpt的设备树节点 id和reset-names相关，值为NULL __of_reset_control_get()解析传入的gpt设备树节点，返回一个reset资源，它不关心这个reset资源是需要新建还是可以从之前的链表中查找到 gpt6: gpt@10048600 { compatible = \"renesas,gpt-r9a07g044l\"; reg = ; #pwm-cells = ; interrupts = , , , , , , , , , , , , ; interrupt-names = \"gtcia\", \"gtcib\", \"gtcic\", \"gtcid\", \"gtcie\", \"gtcif\", \"gtciada\", \"gtciadb\", \"gtciv\", \"gtciu\", \"gtcih\", \"gtcil\", \"gtdei\"; clocks = ; power-domains = ; resets = ; status = \"disabled\"; }; &gpt6 { pinctrl-0 = ; pinctrl-names = \"default\"; channel=\"both_AB\"; status = \"okay\"; }; struct reset_control *__of_reset_control_get(struct device_node *node, const char *id, int index, bool shared, bool optional) { struct reset_control *rstc; struct reset_controller_dev *r, *rcdev; struct of_phandle_args args; int rstc_id; int ret; if (!node) return ERR_PTR(-EINVAL); if (id) { //id是传入的形参，值为NULL index = of_property_match_string(node, \"reset-names\", id); if (index == -EILSEQ) return ERR_PTR(index); if (index of_node) { //args.np是指向设备树中某个节点的指针 rcdev = r; break; } } if (!rcdev) { rstc = ERR_PTR(-EPROBE_DEFER); goto out; } if (WARN_ON(args.args_count != rcdev->of_reset_n_cells)) { rstc = ERR_PTR(-EINVAL); goto out; } ////在这之前的代码整体就是为了获得rcdev操作句柄，g2l只有一个reset_controller_dev rstc_id = rcdev->of_xlate(rcdev, &args); //解析gpt设备树节点中resets属性，获取要复位的外设的index，include/dt-bindings/clock/r9a07g044l-cpg.h if (rstc_id 4.5.1. 关于of_parse_phandle_with_args() https://blog.csdn.net/mars_Vessalius/article/details/116483979 /** * of_parse_phandle_with_args() - Find a node pointed by phandle in a list * @np: pointer to a device tree node containing a list * @list_name: property name that contains a list * @cells_name: property name that specifies phandles' arguments count * @index: index of a phandle to parse out * @out_args: optional pointer to output arguments structure (will be filled) * * This function is useful to parse lists of phandles and their arguments. * Returns 0 on success and fills out_args, on error returns appropriate * errno value. * * Caller is responsible to call of_node_put() on the returned out_args->np * pointer. * * Example: * * phandle1: node1 { * #list-cells = ; * } * * phandle2: node2 { * #list-cells = ; * } * * node3 { * list = ; * } * * To get a device_node of the `node2' node you may call this: * of_parse_phandle_with_args(node3, \"list\", \"#list-cells\", 1, &args); */ int of_parse_phandle_with_args(const struct device_node *np, const char *list_name, const char *cells_name, int index, struct of_phandle_args *out_args) 这里的#list-cells指的是引用的时候需要几个参数，对于node3，node3中定义了list属性，类似一个数组。在list数组中有两个元素，这两个元素分别是对phandle1和phandle2的引用，而且要根据phandle1和phandle2的#list-cells的值写入相应个数的参数。即，phandle1的参数1 2，phandle2的参数 3 ？？？？？ 对于gpt代码来说， ret = of_parse_phandle_with_args(node, \"resets\", \"#reset-cells\", index, &args); 也就是在node节点（gpt6节点）中的resets属性中查找第0个？？？ https://www.kernel.org/doc/Documentation/devicetree/bindings/reset/reset.txt 怀疑是复位信号有问题，但是，对比了手册 7.2.4.138 Reset Control Register SCIF (CPG_RST_SCIF)和 7.2.4.121 Reset Control Register GPT (CPG_RST_GPT) 结果发现，对于gpt来说，只有一个复位信号，不像scif，能分别对01234复位。所以这个就是为什么关于gpt的描述，手册里面写他有8个channel？ 4.6. __reset_control_get_internal(rcdev, index, shared) rcdev最终指向的是reset_controller_dev，对于G2L来说就是cpg，唯一 index是设备树中gpt节点的resets属性的值 shared，bool，是否为共享资源index __reset_control_get_internal()根据index查找符合要求的rstc，或者新建rstc并加入reset_controller_dev的队列，交由reset_controller_dev管理 如果要查找的reset资源已经存在于链表里，并且这个资源是shared，就直接返回这个reset资源；如果不是shared，那就报错return ERR_PTR(-EBUSY); static struct reset_control *__reset_control_get_internal( struct reset_controller_dev *rcdev, unsigned int index, bool shared) { struct reset_control *rstc; lockdep_assert_held(&reset_list_mutex); list_for_each_entry(rstc, &rcdev->reset_control_head, list) { if (rstc->id == index) { if (WARN_ON(!rstc->shared || !shared)) return ERR_PTR(-EBUSY); //-16是从这里返回的 kref_get(&rstc->refcnt); //refer count return rstc; } } rstc = kzalloc(sizeof(*rstc), GFP_KERNEL); if (!rstc) return ERR_PTR(-ENOMEM); try_module_get(rcdev->owner); rstc->rcdev = rcdev; list_add(&rstc->list, &rcdev->reset_control_head); rstc->id = index; kref_init(&rstc->refcnt); rstc->shared = shared; return rstc; } 5. 结论 修改 drivers/pwm/gpt-rzg2l.c static int rzg2l_gpt_probe(struct platform_device *pdev) { ... // rzg2l_gpt->rstc = devm_reset_control_get(&pdev->dev, NULL); rzg2l_gpt->rstc = devm_reset_control_get_shared(&pdev->dev, NULL); if (IS_ERR(rzg2l_gpt->rstc)) { dev_err(δpdev->dev, \"failed to get cpg reset\\n\"); return PTR_ERR(rzg2l_gpt->rstc); } ... } 6. 参考 Reset controller API - kernel.org Linux reset framework - 蜗窝科技 "}}